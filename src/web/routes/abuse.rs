use askama::Template;
use axum::{
    extract::{Path, Query, State},
    response::{Html, IntoResponse, Redirect, Response},
    Form,
};
use base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine};
use log::{debug, error, info, warn};
use serde::Deserialize;

use crate::db::{Account, AbuseInbox};
use crate::web::{auth::AuthAdmin, fire_webhook, AppState};

// ── Constants ──

const MAILDIR_ROOT: &str = "/data/mail";
const REPORTS_PER_PAGE: usize = 10;

// ── Helpers ──

fn is_safe_path_component(s: &str) -> bool {
    !s.is_empty() && !s.contains('/') && !s.contains('\\') && s != "." && s != ".."
}

fn maildir_path(domain: &str, username: &str) -> String {
    format!("{}/{}/{}/Maildir", MAILDIR_ROOT, domain, username)
}

// ── RFC 2142 – Mailbox Names for Common Services ──
//
// RFC 2142 (May 1997, "Mailbox Names for Common Services, Roles and Functions")
// standardises a set of well-known mailbox names that every Internet domain
// SHOULD maintain.  Section 2 defines the "ABUSE" mailbox:
//
//   "ABUSE   — reporting inappropriate public behaviour"
//
// Any domain that sends or relays email is expected to accept mail addressed
// to <abuse@domain>.  Mail sent to this address is typically:
//   • Unsolicited bulk e-mail (spam) complaints forwarded by recipients.
//   • Automated Feedback Loop (FBL) reports generated by large ISPs/ESPs
//     (e.g. Yahoo, Comcast, AOL) when their users click "This is Spam".
//   • Network-abuse complaints (dictionary-attack attempts, bounces, etc.).
//
// RFC 2142 does not mandate a machine-readable format; it only requires the
// mailbox exist and be monitored.  The structured, machine-readable format for
// those reports is defined separately by RFC 5965 (see section below).
//
// Relationship between RFC 2142 and RFC 5965
// ------------------------------------------
//  RFC 2142  →  WHERE reports are sent  (abuse@your-domain)
//  RFC 5965  →  HOW  reports are encoded (ARF – Abuse Reporting Format)
//
// This module implements both layers:
//   1. It watches designated mailboxes (the RFC 2142 abuse address) for
//      incoming mail.
//   2. It parses the ARF envelope (RFC 5965) from those messages to surface
//      structured data such as Feedback-Type, Source-IP, and Reported-Domain.

// ── ARF (RFC 5965) data structures ──
//
// RFC 5965 defines the Abuse Reporting Format (ARF), also called the
// Messaging Abuse Reporting Format (MARF).  An ARF message is a
// "multipart/report; report-type=feedback-report" MIME container with
// (at minimum) three parts:
//
//   Part 1 – text/plain  : Human-readable description of the complaint.
//   Part 2 – message/feedback-report : Machine-readable key/value fields
//            (parsed by parse_feedback_report_part() below).
//   Part 3 – message/rfc822 or text/rfc822-headers : The original message
//            or its headers, giving context about the reported email.
//
// Required fields in the feedback-report part (RFC 5965 §3.1):
//   Feedback-Type  – category of the report (MUST be present)
//   Version        – always "1" for RFC 5965 reports
//
// Common optional fields:
//   User-Agent      – the software/service generating the report
//   Source-IP       – IPv4/IPv6 of the MTA that injected the message
//   Reported-Domain – domain alleged to have sent abusive mail
//   Arrival-Date    – when the message arrived at the reporter's MTA
//   Original-Rcpt-To  – envelope recipient at the reporting MTA
//   Original-Mail-From – envelope sender (MAIL FROM) of the original message

/// Machine-readable fields extracted from the `message/feedback-report` MIME
/// part of an ARF message (RFC 5965 §3).
///
/// The `feedback_type` field is the only one guaranteed to be present in a
/// valid report; all others are optional per the RFC.  Known `Feedback-Type`
/// values registered with IANA include:
///   "abuse"    – general unsolicited bulk email / spam (most common)
///   "fraud"    – phishing or other fraudulent mail
///   "virus"    – message contained malware
///   "not-spam" – false-positive report (message was *not* spam)
///   "other"    – does not fit any of the above categories
#[derive(Default, Clone)]
pub struct AbuseReportFields {
    /// `Feedback-Type` — category of the complaint (required by RFC 5965 §3.1).
    /// Common values: "abuse", "spam", "fraud", "virus", "not-spam", "other".
    pub feedback_type: String,
    /// `Version` — ARF schema version; always "1" for RFC 5965 reports.
    pub version: String,
    /// `User-Agent` — MUA or FBL service that generated the report
    /// (e.g. "SomeISP-FBL/1.0").
    pub user_agent: String,
    /// `Reported-Domain` — the domain alleged to have sent abusive mail.
    /// Corresponds to the domain portion of the envelope sender or
    /// the visible From address of the original message.
    pub reported_domain: String,
    /// `Source-IP` — IP address of the MTA that originally injected the
    /// reported message into the Internet mail infrastructure.
    pub source_ip: String,
    /// `Arrival-Date` — date/time the original message arrived at the
    /// reporter's mail system (RFC 2822 date format).
    pub arrival_date: String,
    /// `Original-Rcpt-To` — the envelope recipient (RCPT TO) address as
    /// recorded at the reporting MTA; identifies *who* received the spam.
    pub original_rcpt_to: String,
    /// `Original-Mail-From` — the envelope sender (MAIL FROM) of the
    /// reported message; may be empty ("") for messages with a null sender.
    pub original_mail_from: String,
}

/// A fully parsed abuse report, combining the outer email metadata with the
/// structured ARF fields and the headers of the original reported message.
///
/// # Background (RFC 2142 + RFC 5965)
/// Email providers that operate Feedback Loops (FBLs) send ARF-formatted
/// complaints to the `abuse@` address of the responsible domain (RFC 2142).
/// Each such email is a `multipart/report` container (RFC 5965) whose
/// machine-readable part is surfaced here as [`AbuseReportFields`].
pub struct AbuseReport {
    /// Subject line of the FBL/complaint email itself.
    pub email_subject: String,
    /// Date header of the FBL/complaint email.
    pub email_date: String,
    /// Unix timestamp parsed from `email_date`; used for sorting.
    pub email_timestamp: i64,
    /// Base64url-encoded Maildir filename; used as a stable identifier.
    #[allow(dead_code)]
    pub email_filename: String,
    /// Structured fields from the `message/feedback-report` MIME part (RFC 5965).
    pub fields: AbuseReportFields,
    /// Subject of the *original* message being reported, extracted from the
    /// embedded `message/rfc822` part (RFC 5965 §3.2, third body part).
    pub original_subject: String,
    /// From header of the *original* message being reported.
    pub original_from: String,
}

// ── ARF parsing ──

/// Parse the body of a `message/feedback-report` MIME part into
/// [`AbuseReportFields`].
///
/// Per RFC 5965 §3.1 the part body is formatted as a set of
/// "header-like" `Field-Name: value` lines (similar to RFC 2822 headers but
/// *not* actual email headers).  Lines are iterated and matched
/// case-insensitively against the known field names defined in the RFC.
///
/// Unknown fields are silently ignored, which is the correct behaviour per
/// RFC 5965 §4 ("Ignoring unknown fields is RECOMMENDED").
fn parse_feedback_report_part(body: &str) -> AbuseReportFields {
    let mut fields = AbuseReportFields::default();
    for line in body.lines() {
        if let Some(colon) = line.find(':') {
            let key = line[..colon].trim().to_lowercase();
            let value = line[colon + 1..].trim().to_string();
            match key.as_str() {
                "feedback-type" => fields.feedback_type = value,
                "version" => fields.version = value,
                "user-agent" => fields.user_agent = value,
                "reported-domain" => fields.reported_domain = value,
                "source-ip" => fields.source_ip = value,
                "arrival-date" => fields.arrival_date = value,
                "original-rcpt-to" => fields.original_rcpt_to = value,
                "original-mail-from" => fields.original_mail_from = value,
                _ => {}
            }
        }
    }
    fields
}

/// Recursively walk the MIME tree of a parsed email looking for the
/// `message/feedback-report` part defined by RFC 5965 §3.
///
/// RFC 5965 §2 specifies that the outer message MUST be
/// `multipart/report; report-type=feedback-report`, but in practice some
/// generators wrap it differently.  Recursing the entire MIME tree (rather
/// than only checking the direct children of `multipart/report`) makes the
/// parser resilient to such deviations.
///
/// Returns `None` when no valid feedback-report part is found, or when the
/// part exists but does not contain the required `Feedback-Type` field.
fn find_feedback_report_part(part: &mailparse::ParsedMail) -> Option<AbuseReportFields> {
    let ct = part.ctype.mimetype.to_lowercase();
    if ct == "message/feedback-report" {
        if let Ok(body) = part.get_body() {
            let fields = parse_feedback_report_part(&body);
            // Only consider it valid if Feedback-Type is present (per RFC 5965)
            if !fields.feedback_type.is_empty() {
                return Some(fields);
            }
        }
    }
    for subpart in &part.subparts {
        if let Some(f) = find_feedback_report_part(subpart) {
            return Some(f);
        }
    }
    None
}

/// Recursively walk the MIME tree looking for the third body part of an ARF
/// message — the `message/rfc822` (or `text/rfc822-headers`) part that
/// contains the *original* reported message (RFC 5965 §3.2).
///
/// Extracting this part allows the admin UI to show the subject and sender
/// of the email that triggered the complaint, giving additional context
/// beyond the structured feedback-report fields.
///
/// Returns `(subject, from)` of the first matching nested message found;
/// both strings are empty when no such part exists.
fn find_original_message_headers(part: &mailparse::ParsedMail) -> (String, String) {
    let ct = part.ctype.mimetype.to_lowercase();
    if ct == "message/rfc822" || ct == "text/rfc822-headers" {
        // Try to parse as a nested email to get headers
        if let Ok(body_raw) = part.get_body_raw() {
            if let Ok(nested) = mailparse::parse_mail(&body_raw) {
                let subject = nested
                    .headers
                    .iter()
                    .find(|h| h.get_key().eq_ignore_ascii_case("Subject"))
                    .map(|h| h.get_value())
                    .unwrap_or_default();
                let from = nested
                    .headers
                    .iter()
                    .find(|h| h.get_key().eq_ignore_ascii_case("From"))
                    .map(|h| h.get_value())
                    .unwrap_or_default();
                return (subject, from);
            }
        }
    }
    for subpart in &part.subparts {
        let result = find_original_message_headers(subpart);
        if !result.0.is_empty() || !result.1.is_empty() {
            return result;
        }
    }
    (String::new(), String::new())
}

/// Scan a Maildir inbox and parse every ARF abuse report found therein.
///
/// # Mailbox convention (RFC 2142)
/// Per RFC 2142 §2, the designated mailbox for receiving abuse complaints
/// is `abuse@<domain>`.  Mail administrators are expected to configure an
/// account with that local-part and point it at a monitored mailbox.  This
/// function reads that Maildir to surface the structured complaints.
///
/// # Report format (RFC 5965)
/// Each qualifying email must be a `multipart/report` message with
/// `report-type=feedback-report` (RFC 5965 §2).  Emails that do not
/// contain a valid `message/feedback-report` MIME part are skipped silently
/// so that routine non-ARF mail delivered to the same address does not
/// produce noise.
///
/// The `on_report` callback is invoked once per successfully parsed report,
/// enabling callers to fire webhooks or perform side-effects without
/// collecting all reports into memory first.
fn read_abuse_reports<F>(maildir_base: &str, logs: &mut Vec<String>, mut on_report: F) -> Vec<AbuseReport>
where
    F: FnMut(&AbuseReport),
{
    let mut reports = Vec::new();
    let mut files: Vec<(String, std::path::PathBuf)> = Vec::new();

    for subdir in &["new", "cur"] {
        let dir_path = format!("{}/{}", maildir_base, subdir);
        match std::fs::read_dir(&dir_path) {
            Ok(entries) => {
                for entry in entries.flatten() {
                    let path = entry.path();
                    if path.is_file() {
                        let fname = entry.file_name().to_string_lossy().to_string();
                        files.push((fname, path));
                    }
                }
            }
            Err(e) => {
                debug!("[abuse] maildir '{}' not accessible: {}", dir_path, e);
            }
        }
    }

    // Process newest-looking filenames first
    files.sort_by(|a, b| b.0.cmp(&a.0));

    for (fname, path) in files {
        match std::fs::read(&path) {
            Ok(data) => match mailparse::parse_mail(&data) {
                Ok(parsed) => {
                    let subject = parsed
                        .headers
                        .iter()
                        .find(|h| h.get_key().eq_ignore_ascii_case("Subject"))
                        .map(|h| h.get_value())
                        .unwrap_or_default();
                    let date = parsed
                        .headers
                        .iter()
                        .find(|h| h.get_key().eq_ignore_ascii_case("Date"))
                        .map(|h| h.get_value())
                        .unwrap_or_default();
                    let email_timestamp = mailparse::dateparse(&date).unwrap_or(0);
                    let encoded = URL_SAFE_NO_PAD.encode(fname.as_bytes());

                    // Check if this is an ARF feedback report email
                    let ct = parsed.ctype.mimetype.to_lowercase();
                    let is_report = ct.contains("multipart/report")
                        || parsed
                            .headers
                            .iter()
                            .find(|h| h.get_key().eq_ignore_ascii_case("Content-Type"))
                            .map(|h| h.get_value().to_lowercase().contains("feedback-report"))
                            .unwrap_or(false);

                    if is_report || !parsed.subparts.is_empty() {
                        if let Some(fields) = find_feedback_report_part(&parsed) {
                            let (original_subject, original_from) =
                                find_original_message_headers(&parsed);
                            let report = AbuseReport {
                                email_subject: subject,
                                email_date: date,
                                email_timestamp,
                                email_filename: encoded,
                                fields,
                                original_subject,
                                original_from,
                            };
                            on_report(&report);
                            reports.push(report);
                        }
                    }
                    // else: not an ARF email, skip silently
                }
                Err(e) => {
                    logs.push(format!("Failed to parse email {}: {}", fname, e));
                }
            },
            Err(e) => {
                logs.push(format!("Failed to read file {}: {}", fname, e));
            }
        }
    }

    reports
}

struct PaginatedReports {
    reports: Vec<AbuseReport>,
    page: usize,
    total_pages: usize,
    total_count: usize,
}

fn paginate_reports(
    mut reports: Vec<AbuseReport>,
    requested_page: usize,
    per_page: usize,
) -> PaginatedReports {
    let per_page = per_page.max(1);
    reports.sort_by(|a, b| {
        b.email_timestamp
            .cmp(&a.email_timestamp)
            .then_with(|| b.email_filename.cmp(&a.email_filename))
    });
    let total_count = reports.len();
    let total_pages = ((total_count + per_page - 1) / per_page).max(1);
    let page = requested_page.max(1).min(total_pages);
    let start = (page - 1) * per_page;
    let reports = reports.into_iter().skip(start).take(per_page).collect();

    PaginatedReports {
        reports,
        page,
        total_pages,
        total_count,
    }
}

// ── Forms ──

#[derive(Deserialize)]
pub struct AddAbuseInboxForm {
    pub account_id: i64,
    pub label: String,
}

#[derive(Deserialize)]
pub struct ReportsQuery {
    #[serde(default = "default_page")]
    pub page: usize,
}

fn default_page() -> usize {
    1
}

// ── Templates ──

#[derive(Template)]
#[template(path = "abuse/list.html")]
struct ListTemplate<'a> {
    nav_active: &'a str,
    flash: Option<String>,
    inboxes: Vec<AbuseInbox>,
    accounts: Vec<Account>,
}

#[derive(Template)]
#[template(path = "abuse/reports.html")]
struct ReportsTemplate<'a> {
    nav_active: &'a str,
    flash: Option<&'a str>,
    inbox: AbuseInbox,
    reports: Vec<AbuseReport>,
    logs: Vec<String>,
    page: usize,
    total_pages: usize,
    total_count: usize,
    page_size: usize,
}

// ── Handlers ──

pub async fn list(
    _auth: AuthAdmin,
    State(state): State<AppState>,
) -> Html<String> {
    info!("[web] GET /abuse — list abuse inboxes");
    let inboxes = state.blocking_db(|db| db.list_abuse_inboxes()).await;
    let accounts = state
        .blocking_db(|db| db.list_all_accounts_with_domain())
        .await;
    let tmpl = ListTemplate {
        nav_active: "Abuse",
        flash: None,
        inboxes,
        accounts,
    };
    Html(tmpl.render().unwrap())
}

pub async fn create(
    _auth: AuthAdmin,
    State(state): State<AppState>,
    Form(form): Form<AddAbuseInboxForm>,
) -> Response {
    info!(
        "[web] POST /abuse — creating abuse inbox account_id={}",
        form.account_id
    );
    let account_id = form.account_id;
    let label = form.label.clone();
    let result = state
        .blocking_db(move |db| db.create_abuse_inbox(account_id, &label))
        .await;
    match result {
        Ok(_) => Redirect::to("/abuse").into_response(),
        Err(e) => {
            error!("[web] failed to create abuse inbox: {}", e);
            let inboxes = state.blocking_db(|db| db.list_abuse_inboxes()).await;
            let accounts = state
                .blocking_db(|db| db.list_all_accounts_with_domain())
                .await;
            let tmpl = ListTemplate {
                nav_active: "Abuse",
                flash: Some(format!("Error: {}", e)),
                inboxes,
                accounts,
            };
            Html(tmpl.render().unwrap()).into_response()
        }
    }
}

pub async fn delete(
    _auth: AuthAdmin,
    State(state): State<AppState>,
    Path(id): Path<i64>,
) -> Response {
    warn!("[web] POST /abuse/{}/delete — deleting abuse inbox", id);
    state.blocking_db(move |db| db.delete_abuse_inbox(id)).await;
    Redirect::to("/abuse").into_response()
}

pub async fn reports(
    _auth: AuthAdmin,
    State(state): State<AppState>,
    Path(id): Path<i64>,
    Query(params): Query<ReportsQuery>,
) -> Response {
    info!("[web] GET /abuse/{}/reports", id);
    let page = params.page.max(1);

    let inbox = match state.blocking_db(move |db| db.get_abuse_inbox(id)).await {
        Some(i) => i,
        None => {
            warn!("[web] abuse inbox id={} not found", id);
            return Redirect::to("/abuse").into_response();
        }
    };

    let username = inbox.account_username.clone().unwrap_or_default();
    let domain = inbox.account_domain.clone().unwrap_or_default();
    let mut logs: Vec<String> = Vec::new();
    logs.push(format!("Reading mailbox: {}", maildir_path(&domain, &username)));

    let webhook_state = state.clone();
    let inbox_for_webhook = inbox.clone();

    let reports = if is_safe_path_component(&domain) && is_safe_path_component(&username) {
        let maildir_base = maildir_path(&domain, &username);
        read_abuse_reports(&maildir_base, &mut logs, |report| {
            fire_webhook(
                &webhook_state,
                "abuse.report.parsed",
                serde_json::json!({
                    "inbox_id": inbox_for_webhook.id,
                    "label": inbox_for_webhook.label,
                    "account": format!(
                        "{}@{}",
                        inbox_for_webhook
                            .account_username
                            .as_deref()
                            .unwrap_or_default(),
                        inbox_for_webhook
                            .account_domain
                            .as_deref()
                            .unwrap_or_default()
                    ),
                    "feedback_type": report.fields.feedback_type,
                    "reported_domain": report.fields.reported_domain,
                    "source_ip": report.fields.source_ip,
                    "original_rcpt_to": report.fields.original_rcpt_to,
                }),
            );
        })
    } else {
        warn!(
            "[web] unsafe path component: domain={}, username={}",
            domain, username
        );
        Vec::new()
    };

    let pagination = paginate_reports(reports, page, REPORTS_PER_PAGE);

    let tmpl = ReportsTemplate {
        nav_active: "Abuse",
        flash: None,
        inbox,
        reports: pagination.reports,
        logs,
        page: pagination.page,
        total_pages: pagination.total_pages,
        total_count: pagination.total_count,
        page_size: REPORTS_PER_PAGE,
    };
    Html(tmpl.render().unwrap()).into_response()
}

#[cfg(test)]
mod tests {
    use super::*;

    fn build_report(ts: i64, subject: &str) -> AbuseReport {
        AbuseReport {
            email_subject: subject.to_string(),
            email_date: "2024-02-20".to_string(),
            email_timestamp: ts,
            email_filename: format!("file-{}", subject),
            fields: AbuseReportFields::default(),
            original_subject: String::new(),
            original_from: String::new(),
        }
    }

    #[test]
    fn paginate_abuse_reports_sorts_and_limits() {
        let reports = vec![
            build_report(2, "second"),
            build_report(3, "third"),
            build_report(1, "first"),
        ];

        let page_one = paginate_reports(reports, 1, 2);
        assert_eq!(page_one.total_count, 3);
        assert_eq!(page_one.total_pages, 2);
        assert_eq!(page_one.page, 1);
        assert_eq!(page_one.reports.len(), 2);
        assert_eq!(page_one.reports[0].email_subject, "third");
        assert_eq!(page_one.reports[1].email_subject, "second");

        let page_two = paginate_reports(
            vec![
                build_report(2, "second"),
                build_report(3, "third"),
                build_report(1, "first"),
            ],
            2,
            2,
        );
        assert_eq!(page_two.page, 2);
        assert_eq!(page_two.reports.len(), 1);
        assert_eq!(page_two.reports[0].email_subject, "first");
    }

    #[test]
    fn parse_feedback_report_part_extracts_fields() {
        let body = "Feedback-Type: abuse\r\nVersion: 1\r\nUser-Agent: TestFBL/1.0\r\nSource-IP: 203.0.113.42\r\nReported-Domain: spammer.example\r\nOriginal-Rcpt-To: victim@example.com\r\nOriginal-Mail-From: sender@spammer.example\r\nArrival-Date: Mon, 12 Feb 2024 10:00:00 +0000\r\n";
        let fields = parse_feedback_report_part(body);
        assert_eq!(fields.feedback_type, "abuse");
        assert_eq!(fields.version, "1");
        assert_eq!(fields.user_agent, "TestFBL/1.0");
        assert_eq!(fields.source_ip, "203.0.113.42");
        assert_eq!(fields.reported_domain, "spammer.example");
        assert_eq!(fields.original_rcpt_to, "victim@example.com");
        assert_eq!(fields.original_mail_from, "sender@spammer.example");
    }

    #[test]
    fn read_abuse_reports_triggers_callback() {
        use std::fs;
        use std::time::{SystemTime, UNIX_EPOCH};

        let base = std::env::temp_dir().join(format!(
            "abuse-test-{}",
            SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_nanos()
        ));
        let new_dir = base.join("new");
        fs::create_dir_all(&new_dir).unwrap();
        fs::create_dir_all(base.join("cur")).unwrap();

        // Minimal ARF feedback report email (RFC 5965)
        let email = concat!(
            "Subject: Abuse Report\r\n",
            "Date: Mon, 12 Feb 2024 10:00:00 +0000\r\n",
            "Content-Type: multipart/report; report-type=feedback-report; boundary=\"ABOUND\"\r\n",
            "\r\n",
            "--ABOUND\r\n",
            "Content-Type: text/plain\r\n",
            "\r\n",
            "This is a spam report.\r\n",
            "--ABOUND\r\n",
            "Content-Type: message/feedback-report\r\n",
            "\r\n",
            "Feedback-Type: abuse\r\n",
            "Version: 1\r\n",
            "User-Agent: TestFBL/1.0\r\n",
            "Source-IP: 203.0.113.42\r\n",
            "Reported-Domain: spammer.example\r\n",
            "Original-Rcpt-To: victim@example.com\r\n",
            "--ABOUND--\r\n",
        );

        let file_path = new_dir.join("1707732000.M12345P123.host");
        fs::write(&file_path, email).unwrap();

        let mut logs = Vec::new();
        let mut seen = Vec::new();
        let reports = read_abuse_reports(base.to_str().unwrap(), &mut logs, |report| {
            seen.push(report.fields.feedback_type.clone());
        });

        assert_eq!(reports.len(), 1);
        assert_eq!(seen, vec!["abuse".to_string()]);
        assert_eq!(reports[0].fields.source_ip, "203.0.113.42");
        assert_eq!(reports[0].fields.reported_domain, "spammer.example");
        assert_eq!(reports[0].fields.original_rcpt_to, "victim@example.com");

        fs::remove_dir_all(&base).unwrap();
    }
}
