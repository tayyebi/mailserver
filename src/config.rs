use crate::db::Database;
use std::fs;
use std::process::Command;

fn safe_filename(name: &str) -> String {
    name.chars()
        .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-')
        .collect()
}

pub fn generate_all_configs(db: &Database, hostname: &str) {
    generate_postfix_main_cf(hostname);
    generate_postfix_master_cf();
    generate_virtual_domains(db);
    generate_virtual_mailboxes(db);
    generate_virtual_aliases(db);
    generate_dovecot_conf(hostname);
    generate_dovecot_passwd(db);
    generate_opendkim_conf();
    generate_opendkim_tables(db);
    postmap_files();
    reload_services();
}

pub fn generate_postfix_main_cf(hostname: &str) {
    let mydomain = hostname.splitn(2, '.').nth(1).unwrap_or(hostname);

    let config = format!(
        r#"# Generated by mailserver
myhostname = {hostname}
mydomain = {mydomain}
myorigin = $mydomain
mydestination = localhost
inet_interfaces = all
inet_protocols = all

# Virtual mailbox delivery via Dovecot LMTP
virtual_transport = lmtp:inet:localhost:24
virtual_mailbox_domains = hash:/etc/postfix/virtual_domains
virtual_mailbox_maps = hash:/etc/postfix/vmailbox
virtual_alias_maps = hash:/etc/postfix/virtual_aliases

# SASL auth via Dovecot
smtpd_sasl_type = dovecot
smtpd_sasl_path = inet:localhost:12345
smtpd_sasl_auth_enable = yes
smtpd_sasl_security_options = noanonymous

# TLS
smtpd_tls_cert_file = /data/ssl/cert.pem
smtpd_tls_key_file = /data/ssl/key.pem
smtpd_tls_security_level = may
smtpd_tls_auth_only = yes
smtp_tls_security_level = may

# Milters
smtpd_milters = inet:localhost:8891
non_smtpd_milters = inet:localhost:8891
milter_default_action = accept

# Content filter for pixel injection
content_filter = pixelfilter:dummy

# Restrictions
smtpd_recipient_restrictions = permit_sasl_authenticated, permit_mynetworks, reject_unauth_destination

# Limits
message_size_limit = 31457280
"#,
        hostname = hostname,
        mydomain = mydomain,
    );

    fs::write("/etc/postfix/main.cf", config).ok();
}

pub fn generate_postfix_master_cf() {
    let config = r#"# Generated by mailserver
# ==========================================================================
# service type  private unpriv  chroot  wakeup  maxproc command + args
# ==========================================================================
smtp      inet  n       -       n       -       -       smtpd
submission inet  n       -       n       -       -       smtpd
  -o syslog_name=postfix/submission
  -o smtpd_tls_security_level=encrypt
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_sasl_type=dovecot
  -o smtpd_sasl_path=inet:localhost:12345
  -o smtpd_recipient_restrictions=permit_sasl_authenticated,reject
smtps     inet  n       -       n       -       -       smtpd
  -o syslog_name=postfix/smtps
  -o smtpd_tls_wrappermode=yes
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_sasl_type=dovecot
  -o smtpd_sasl_path=inet:localhost:12345
  -o smtpd_recipient_restrictions=permit_sasl_authenticated,reject
127.0.0.1:10025 inet n  -       n       -       -       smtpd
  -o content_filter=
  -o receive_override_options=no_unknown_recipient_checks,no_header_body_checks
  -o smtpd_recipient_restrictions=permit_mynetworks,reject
pixelfilter unix -      n       n       -       10      pipe
  flags=Rq user=nobody argv=/usr/local/bin/mailserver filter -f ${sender} -- ${recipient}
lmtp      unix  -       -       n       -       -       lmtp
"#;

    fs::write("/etc/postfix/master.cf", config).ok();
}

pub fn generate_virtual_domains(db: &Database) {
    let domains = db.list_domains();
    let mut lines = String::from("# Generated by mailserver\n");
    for d in &domains {
        if d.active {
            lines.push_str(&format!("{} OK\n", d.domain));
        }
    }
    fs::write("/etc/postfix/virtual_domains", lines).ok();
}

pub fn generate_virtual_mailboxes(db: &Database) {
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = String::from("# Generated by mailserver\n");
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{} {}/{}/Maildir/\n",
                a.username, domain, domain, a.username
            ));
        }
    }
    fs::write("/etc/postfix/vmailbox", lines).ok();
}

pub fn generate_virtual_aliases(db: &Database) {
    let aliases = db.list_all_aliases_with_domain();
    let mut lines = String::from("# Generated by mailserver\n");
    for a in &aliases {
        if a.active {
            lines.push_str(&format!("{} {}\n", a.source, a.destination));
        }
    }
    fs::write("/etc/postfix/virtual_aliases", lines).ok();
}

pub fn generate_dovecot_conf(hostname: &str) {
    let config = format!(
        r#"# Generated by mailserver
protocols = imap pop3 lmtp
hostname = {hostname}

mail_location = maildir:/data/mail/%d/%n/Maildir

ssl = required
ssl_cert = </data/ssl/cert.pem
ssl_key = </data/ssl/key.pem

passdb {{
  driver = passwd-file
  args = /etc/dovecot/passwd
}}

userdb {{
  driver = static
  args = uid=vmail gid=vmail home=/data/mail/%d/%n
}}

service auth {{
  inet_listener sasl {{
    port = 12345
  }}
}}

service lmtp {{
  inet_listener lmtp {{
    port = 24
  }}
}}

namespace inbox {{
  inbox = yes

  mailbox Sent {{
    auto = subscribe
    special_use = \Sent
  }}

  mailbox Drafts {{
    auto = subscribe
    special_use = \Drafts
  }}

  mailbox Trash {{
    auto = subscribe
    special_use = \Trash
  }}

  mailbox Junk {{
    auto = subscribe
    special_use = \Junk
  }}
}}
"#,
        hostname = hostname,
    );

    fs::write("/etc/dovecot/dovecot.conf", config).ok();
}

pub fn generate_dovecot_passwd(db: &Database) {
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = String::new();
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{}:{{BLF-CRYPT}}{}:::::\n",
                a.username, domain, a.password_hash
            ));
        }
    }
    fs::write("/etc/dovecot/passwd", lines).ok();
}

pub fn generate_opendkim_conf() {
    let config = r#"# Generated by mailserver
Syslog          yes
SyslogSuccess   yes
LogWhy          yes
Mode            sv
Canonicalization relaxed/simple
KeyTable        /etc/opendkim/KeyTable
SigningTable     refile:/etc/opendkim/SigningTable
ExternalIgnoreList /etc/opendkim/TrustedHosts
InternalHosts   /etc/opendkim/TrustedHosts
Socket          inet:8891@localhost
PidFile         /run/opendkim/opendkim.pid
UserID          opendkim
UMask           007
"#;

    fs::write("/etc/opendkim/opendkim.conf", config).ok();
}

pub fn generate_opendkim_tables(db: &Database) {
    let domains = db.list_domains();

    let mut key_table = String::from("# Generated by mailserver\n");
    let mut signing_table = String::from("# Generated by mailserver\n");
    let mut trusted_hosts = String::from("# Generated by mailserver\n127.0.0.1\nlocalhost\n");

    for d in &domains {
        if !d.active {
            continue;
        }
        if let Some(ref private_key) = d.dkim_private_key {
            let selector = &d.dkim_selector;
            let domain = &d.domain;
            let key_path = format!("/data/dkim/{}.private", safe_filename(domain));

            // Write the private key file
            fs::create_dir_all("/data/dkim").ok();
            fs::write(&key_path, private_key).ok();

            key_table.push_str(&format!(
                "{}._domainkey.{} {}:{}:{}\n",
                selector, domain, domain, selector, key_path
            ));
            signing_table.push_str(&format!(
                "*@{} {}._domainkey.{}\n",
                domain, selector, domain
            ));
            trusted_hosts.push_str(&format!("{}\n", domain));
        }
    }

    fs::write("/etc/opendkim/KeyTable", key_table).ok();
    fs::write("/etc/opendkim/SigningTable", signing_table).ok();
    fs::write("/etc/opendkim/TrustedHosts", trusted_hosts).ok();
}

pub fn postmap_files() {
    for path in &[
        "/etc/postfix/virtual_domains",
        "/etc/postfix/vmailbox",
        "/etc/postfix/virtual_aliases",
    ] {
        Command::new("postmap").arg(path).output().ok();
    }
}

pub fn reload_services() {
    Command::new("postfix").arg("reload").output().ok();
    Command::new("dovecot").arg("reload").output().ok();

    // Signal opendkim to reload via USR1
    if let Ok(output) = Command::new("pgrep").arg("opendkim").output() {
        let pids = String::from_utf8_lossy(&output.stdout);
        for pid in pids.split_whitespace() {
            Command::new("kill").args(["-USR1", pid]).output().ok();
        }
    }
}
