use crate::db::Database;
use chrono::Utc;
use log::{debug, error, info, warn};
use std::fs;
use std::io::Write;
use std::path::Path;
use std::process::Command;

#[cfg(unix)]
use std::os::unix::fs::OpenOptionsExt;

// ── Template Loading ──

fn load_template(filename: &str) -> std::io::Result<String> {
    // Try to load from templates/config directory
    let paths = vec![
        format!("templates/config/{}", filename),
        format!("/app/templates/config/{}", filename),
    ];

    for path in paths {
        if Path::new(&path).exists() {
            debug!("[config] loading template from {}", path);
            return fs::read_to_string(path);
        }
    }

    Err(std::io::Error::new(
        std::io::ErrorKind::NotFound,
        format!("Template {} not found in any template directory", filename),
    ))
}

fn safe_filename(name: &str) -> String {
    name.chars()
        .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-')
        .collect()
}

fn generated_header() -> String {
    generated_header_with(&generated_at())
}

fn generated_header_with(timestamp: &str) -> String {
    format!("# Generated by mailserver on {}\n", timestamp)
}

fn generated_at() -> String {
    Utc::now().to_rfc3339()
}

/// Write content to a file with secure permissions (0600 - owner read/write only)
/// This is used for sensitive files like DKIM private keys and password databases
/// 
/// Defense in depth approach:
/// 1. mode(0o600) sets permissions on newly created files
/// 2. set_permissions() ensures correct permissions even if file already existed
/// 3. truncate(true) clears existing content before writing
/// 4. sync_all() ensures data is flushed to disk
#[cfg(unix)]
fn write_secure_file(path: &str, content: &str) -> std::io::Result<()> {
    use std::fs::{OpenOptions, Permissions};
    use std::os::unix::fs::PermissionsExt;
    
    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .mode(0o600)  // Sets permissions for newly created files
        .open(path)?;
    
    file.write_all(content.as_bytes())?;
    
    // Ensure data is flushed to disk
    file.sync_all()?;
    
    // Explicitly set permissions to ensure they're correct even if file existed
    // This is necessary because .mode() only affects newly created files
    let permissions = Permissions::from_mode(0o600);
    std::fs::set_permissions(path, permissions)?;
    
    Ok(())
}

/// Fallback for non-Unix systems (Windows, etc.)
/// WARNING: This does not enforce secure file permissions
#[cfg(not(unix))]
fn write_secure_file(path: &str, content: &str) -> std::io::Result<()> {
    warn!(
        "[config] Writing {} without secure permissions - platform does not support Unix file modes",
        path
    );
    fs::write(path, content)
}

#[cfg(unix)]
fn set_dovecot_passwd_permissions(path: &str) -> std::io::Result<()> {
    use std::fs::Permissions;
    use std::os::unix::fs::PermissionsExt;
    
    std::fs::set_permissions(path, Permissions::from_mode(0o640))?;
    let output = Command::new("chown").args(["root:dovecot", path]).output()?;
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(std::io::Error::other(format!(
            "chown root:dovecot {} failed with status {}: {}",
            path, output.status, stderr
        )));
    }
    
    Ok(())
}

pub fn generate_all_configs(db: &Database, hostname: &str) {
    info!(
        "[config] generating all configuration files for hostname={}",
        hostname
    );
    generate_postfix_main_cf(db, hostname);
    generate_postfix_master_cf(db);
    generate_virtual_domains(db);
    generate_virtual_mailboxes(db);
    generate_virtual_aliases(db);
    generate_sender_login_maps(db);
    generate_dovecot_conf(hostname);
    generate_dovecot_passwd(db);
    generate_opendkim_conf();
    generate_opendkim_tables(db);
    postmap_files();
    reload_services();
    info!("[config] all configuration files generated successfully");
}

pub fn generate_postfix_main_cf(db: &Database, hostname: &str) {
    info!(
        "[config] generating /etc/postfix/main.cf for hostname={}",
        hostname
    );
    let mydomain = hostname.splitn(2, '.').nth(1).unwrap_or(hostname);

    let template = load_template("postfix-main.cf.txt").expect("postfix-main.cf.txt template not found");
    let generated_at = generated_at();

    let milter_enabled = db
        .get_setting("feature_milter_enabled")
        .map(|v| v != "false")
        .unwrap_or(true);

    let milter_config = if milter_enabled {
        "smtpd_milters = inet:127.0.0.1:8891\nnon_smtpd_milters = inet:127.0.0.1:8891\nmilter_default_action = accept".to_string()
    } else {
        "# milter disabled via feature settings".to_string()
    };

    let rbl_hostnames = db.list_enabled_spambl_hostnames();
    // Trailing ", " is intentional: the placeholder sits before reject_unauth_destination
    // in the template, so each rbl check must be followed by a comma separator.
    let rbl_checks = if rbl_hostnames.is_empty() {
        String::new()
    } else {
        rbl_hostnames
            .iter()
            .map(|h| format!("warn_if_reject reject_rbl_client {}", h))
            .collect::<Vec<_>>()
            .join(", ")
            + ", "
    };

    let config = template
        .replace("{{ generated_at }}", &generated_at)
        .replace("{{ hostname }}", hostname)
        .replace("{{ mydomain }}", mydomain)
        .replace("{{ milter_config }}", &milter_config)
        .replace("{{ rbl_checks }}", &rbl_checks);

    match fs::write("/etc/postfix/main.cf", config) {
        Ok(_) => debug!("[config] wrote /etc/postfix/main.cf"),
        Err(e) => error!("[config] failed to write /etc/postfix/main.cf: {}", e),
    }
}

pub fn generate_postfix_master_cf(db: &Database) {
    info!("[config] generating /etc/postfix/master.cf");
    let template = load_template("postfix-master.cf.txt").expect("postfix-master.cf.txt template not found");

    let filter_enabled = db
        .get_setting("feature_filter_enabled")
        .map(|v| v != "false")
        .unwrap_or(true);

    let filter_line = if filter_enabled {
        "  -o content_filter=pixelfilter:local\n"
    } else {
        ""
    };

    let filter_service = if filter_enabled {
        "# Pixel filter service\npixelfilter unix -   y   n   -   10  pipe\n  flags=hq user=postfix argv=/usr/local/bin/mailserver filter -f ${sender} -- ${recipient}\n"
    } else {
        "# Pixel filter service disabled via feature settings\n"
    };

    let config = template
        .replace("{{ generated_at }}", &generated_at())
        .replace("{{ filter_submission }}", filter_line)
        .replace("{{ filter_smtps }}", filter_line)
        .replace("{{ filter_service }}", filter_service);

    match fs::write("/etc/postfix/master.cf", config) {
        Ok(_) => debug!("[config] wrote /etc/postfix/master.cf"),
        Err(e) => error!("[config] failed to write /etc/postfix/master.cf: {}", e),
    }
}

pub fn generate_virtual_domains(db: &Database) {
    info!("[config] generating /etc/postfix/virtual_domains");
    let domains = db.list_domains();
    let mut lines = generated_header();
    for d in &domains {
        if d.active {
            lines.push_str(&format!("{} OK\n", d.domain));
        }
    }
    match fs::write("/etc/postfix/virtual_domains", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/virtual_domains ({} domains)",
            domains.len()
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/virtual_domains: {}",
            e
        ),
    }
}

pub fn generate_virtual_mailboxes(db: &Database) {
    info!("[config] generating /etc/postfix/vmailbox");
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = generated_header();
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{} {}/{}/Maildir/\n",
                a.username, domain, domain, a.username
            ));
        }
    }
    match fs::write("/etc/postfix/vmailbox", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/vmailbox ({} accounts)",
            accounts.len()
        ),
        Err(e) => error!("[config] failed to write /etc/postfix/vmailbox: {}", e),
    }
}

pub fn generate_virtual_aliases(db: &Database) {
    info!("[config] generating /etc/postfix/virtual_aliases");
    let aliases = db.list_all_aliases_with_domain();
    let forwardings = db.list_all_forwardings_with_domain();
    let mut lines = generated_header();

    let mut active_count = 0;
    for a in &aliases {
        if a.active {
            lines.push_str(&format!(
                "{} {}\n",
                normalize_virtual_alias_source(&a.source, a.domain_name.as_deref()),
                a.destination
            ));
            active_count += 1;
        }
    }

    // Forwardings: when keep_copy is set, deliver to both the source mailbox and the external address
    for f in &forwardings {
        if f.active {
            let destination = if f.keep_copy {
                format!("{}, {}", f.source, f.destination)
            } else {
                f.destination.clone()
            };
            lines.push_str(&format!("{} {}\n", f.source, destination));
            active_count += 1;
        }
    }

    // Add a comment if there are no active aliases or forwardings to make the file more informative
    if active_count == 0 {
        lines.push_str("# No active aliases or forwardings configured\n");
        lines.push_str("# Add aliases or forwarding rules in the admin dashboard\n");
    }

    match write_secure_file("/etc/postfix/virtual_aliases", &lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/virtual_aliases with secure permissions ({} active entries)",
            active_count
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/virtual_aliases: {}",
            e
        ),
    }
}

fn normalize_virtual_alias_source(source: &str, domain: Option<&str>) -> String {
    let trimmed = source.trim();
    if let Some(rest) = trimmed.strip_prefix("*@") {
        return format!("@{}", rest);
    }
    if trimmed == "*" {
        if let Some(domain) = domain {
            return format!("@{}", domain);
        } else {
            warn!("[config] alias source '*' has no domain context; keeping source as-is");
            return trimmed.to_string();
        }
    }
    trimmed.to_string()
}

pub fn generate_sender_login_maps(db: &Database) {
    info!("[config] generating /etc/postfix/sender_login_maps");
    let entries = db.get_sender_login_map();

    // Group by alias source: normalize wildcards (*@domain → @domain) so Postfix
    // can use them for wildcard lookups in smtpd_sender_login_maps.
    let mut map: std::collections::HashMap<String, Vec<String>> = std::collections::HashMap::new();
    for (alias_source, account_email) in &entries {
        let normalized_source = normalize_virtual_alias_source(alias_source, None);
        map.entry(normalized_source)
            .or_default()
            .push(account_email.clone());
    }

    // Also allow each account to send as itself
    let accounts = db.list_all_accounts_with_domain();
    for a in &accounts {
        if a.active {
            if let Some(ref domain) = a.domain_name {
                let email = format!("{}@{}", a.username, domain);
                map.entry(email.clone()).or_default().push(email);
            }
        }
    }

    let mut lines = generated_header();
    for (sender, logins) in &map {
        // Deduplicate logins
        let mut unique: Vec<&String> = logins.iter().collect();
        unique.sort();
        unique.dedup();
        lines.push_str(&format!(
            "{} {}\n",
            sender,
            unique
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<_>>()
                .join(",")
        ));
    }
    match write_secure_file("/etc/postfix/sender_login_maps", &lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/sender_login_maps with secure permissions ({} entries)",
            map.len()
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/sender_login_maps: {}",
            e
        ),
    }
}

pub fn generate_dovecot_conf(hostname: &str) {
    info!(
        "[config] generating /etc/dovecot/dovecot.conf for hostname={}",
        hostname
    );
    let template = load_template("dovecot.conf.txt").expect("dovecot.conf.txt template not found");

    let config = template
        .replace("{{ generated_at }}", &generated_at())
        .replace("{{ hostname }}", hostname);

    match fs::write("/etc/dovecot/dovecot.conf", config) {
        Ok(_) => debug!("[config] wrote /etc/dovecot/dovecot.conf"),
        Err(e) => error!("[config] failed to write /etc/dovecot/dovecot.conf: {}", e),
    }
}

pub fn generate_dovecot_passwd(db: &Database) {
    let passwd_path = "/etc/dovecot/passwd";
    info!("[config] generating {}", passwd_path);
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = String::new();
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{}:{{BLF-CRYPT}}{}:::::\n",
                a.username, domain, a.password_hash
            ));
        }
    }
    match write_secure_file(passwd_path, &lines) {
        Ok(_) => {
            #[cfg(unix)]
            if let Err(e) = set_dovecot_passwd_permissions(passwd_path) {
                use std::fs::Permissions;
                use std::os::unix::fs::PermissionsExt;

                warn!(
                    "[config] failed to set /etc/dovecot/passwd ownership/permissions ({}), falling back to mode 0644",
                    e
                );
                if let Err(e2) = std::fs::set_permissions(passwd_path, Permissions::from_mode(0o644)) {
                    error!("[config] failed to apply fallback permissions for /etc/dovecot/passwd: {}", e2);
                    return;
                }
            }
            debug!(
                "[config] wrote /etc/dovecot/passwd with secure permissions ({} accounts)",
                accounts.len()
            )
        }
        Err(e) => error!("[config] failed to write /etc/dovecot/passwd: {}", e),
    }
}

pub fn generate_opendkim_conf() {
    info!("[config] generating /etc/opendkim/opendkim.conf");
    let template = load_template("opendkim.conf.txt").expect("opendkim.conf.txt template not found");
    let config = template.replace("{{ generated_at }}", &generated_at());

    match fs::write("/etc/opendkim/opendkim.conf", config) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/opendkim.conf"),
        Err(e) => error!(
            "[config] failed to write /etc/opendkim/opendkim.conf: {}",
            e
        ),
    }
}

pub fn generate_opendkim_tables(db: &Database) {
    info!("[config] generating OpenDKIM key/signing/trusted tables");
    let domains = db.list_domains();

    let timestamp = generated_at();
    let header = generated_header_with(&timestamp);
    let mut key_table = header.clone();
    let mut signing_table = header.clone();
    let mut trusted_hosts = format!("{}127.0.0.1\nlocalhost\n", header);
    let mut dkim_count: usize = 0;

    for d in &domains {
        if !d.active {
            debug!("[config] skipping inactive domain {} for DKIM", d.domain);
            continue;
        }
        if let Some(ref private_key) = d.dkim_private_key {
            let selector = &d.dkim_selector;
            let domain = &d.domain;
            let key_path = format!("/data/dkim/{}.private", safe_filename(domain));

            // Write the private key file with secure permissions (0600)
            if let Err(e) = fs::create_dir_all("/data/dkim") {
                error!("[config] failed to create /data/dkim directory: {}", e);
            }
            match write_secure_file(&key_path, private_key) {
                Ok(_) => {
                    debug!(
                        "[config] wrote DKIM private key for domain={} to {} with secure permissions",
                        domain, key_path
                    );
                    // Ensure opendkim (which drops privileges to the opendkim user via UserID in
                    // opendkim.conf) can read the private key file.
                    match Command::new("chown").args(["opendkim:opendkim", &key_path]).output() {
                        Ok(o) if o.status.success() => debug!(
                            "[config] set opendkim ownership on {}",
                            key_path
                        ),
                        Ok(o) => warn!(
                            "[config] chown opendkim:opendkim {} failed: {}",
                            key_path,
                            String::from_utf8_lossy(&o.stderr)
                        ),
                        Err(e) => warn!("[config] failed to chown {}: {}", key_path, e),
                    }
                }
                Err(e) => error!(
                    "[config] failed to write DKIM private key for domain={}: {}",
                    domain, e
                ),
            }

            key_table.push_str(&format!(
                "{}._domainkey.{} {}:{}:{}\n",
                selector, domain, domain, selector, key_path
            ));
            signing_table.push_str(&format!(
                "*@{} {}._domainkey.{}\n",
                domain, selector, domain
            ));
            trusted_hosts.push_str(&format!("{}\n", domain));
            dkim_count += 1;
        } else {
            debug!("[config] domain {} has no DKIM key configured", d.domain);
        }
    }

    info!(
        "[config] writing OpenDKIM tables ({} DKIM-enabled domains)",
        dkim_count
    );
    match fs::write("/etc/opendkim/KeyTable", key_table) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/KeyTable"),
        Err(e) => error!("[config] failed to write /etc/opendkim/KeyTable: {}", e),
    }
    match fs::write("/etc/opendkim/SigningTable", signing_table) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/SigningTable"),
        Err(e) => error!("[config] failed to write /etc/opendkim/SigningTable: {}", e),
    }
    match fs::write("/etc/opendkim/TrustedHosts", trusted_hosts) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/TrustedHosts"),
        Err(e) => error!("[config] failed to write /etc/opendkim/TrustedHosts: {}", e),
    }
}

pub fn postmap_files() {
    info!("[config] running postmap on virtual maps");
    for path in &[
        "/etc/postfix/virtual_domains",
        "/etc/postfix/vmailbox",
        "/etc/postfix/virtual_aliases",
        "/etc/postfix/sender_login_maps",
    ] {
        // Explicitly specify lmdb format for Alpine Linux compatibility
        let lmdb_path = format!("lmdb:{}", path);
        match Command::new("postmap").arg(&lmdb_path).output() {
            Ok(output) if output.status.success() => {
                debug!("[config] postmap succeeded for {}", lmdb_path);
            }
            Ok(output) => {
                warn!(
                    "[config] postmap for {} exited with status {}: {}",
                    lmdb_path,
                    output.status,
                    String::from_utf8_lossy(&output.stderr)
                );
            }
            Err(e) => {
                warn!("[config] failed to run postmap for {}: {}", lmdb_path, e);
            }
        }
    }
}

pub fn reload_services() {
    info!("[config] reloading mail services");

    match Command::new("postfix").arg("reload").output() {
        Ok(output) if output.status.success() => info!("[config] postfix reloaded successfully"),
        Ok(output) => warn!(
            "[config] postfix reload exited with status {}: {}",
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ),
        Err(e) => warn!("[config] failed to reload postfix: {}", e),
    }

    match Command::new("dovecot").arg("reload").output() {
        Ok(output) if output.status.success() => info!("[config] dovecot reloaded successfully"),
        Ok(output) => warn!(
            "[config] dovecot reload exited with status {}: {}",
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ),
        Err(e) => warn!("[config] failed to reload dovecot: {}", e),
    }

    // Signal opendkim to reload via USR1
    match Command::new("pgrep").arg("opendkim").output() {
        Ok(output) => {
            let pids = String::from_utf8_lossy(&output.stdout);
            for pid in pids.split_whitespace() {
                match Command::new("kill").args(["-USR1", pid]).output() {
                    Ok(_) => debug!("[config] sent USR1 to opendkim pid={}", pid),
                    Err(e) => warn!("[config] failed to signal opendkim pid={}: {}", pid, e),
                }
            }
            if pids.trim().is_empty() {
                debug!("[config] no opendkim process found to signal");
            }
        }
        Err(e) => warn!("[config] failed to find opendkim process: {}", e),
    }

    info!("[config] service reload complete");
}

pub fn restart_services() -> Result<String, String> {
    info!("[config] restarting all mail services via supervisorctl");

    let programs = ["postfix", "dovecot", "opendkim"];
    let mut results = Vec::new();

    for program in &programs {
        match Command::new("supervisorctl")
            .args(["restart", program])
            .output()
        {
            Ok(output) if output.status.success() => {
                info!("[config] {} restarted successfully", program);
                results.push(format!("{}: restarted", program));
            }
            Ok(output) => {
                let stderr = String::from_utf8_lossy(&output.stderr);
                warn!(
                    "[config] supervisorctl restart {} exited with status {}: {}",
                    program, output.status, stderr
                );
                results.push(format!("{}: failed ({})", program, stderr.trim()));
            }
            Err(e) => {
                warn!("[config] failed to restart {}: {}", program, e);
                results.push(format!("{}: error ({})", program, e));
            }
        }
    }

    info!("[config] service restart complete");
    Ok(results.join("; "))
}

pub fn restart_container() -> Result<(), String> {
    info!("[config] restarting Docker container via socket");

    let socket_path = "/var/run/docker.sock";
    if !Path::new(socket_path).exists() {
        error!("[config] Docker socket not found at {}", socket_path);
        return Err("Docker socket not found. Ensure /var/run/docker.sock is mounted into the container.".to_string());
    }

    // Read our own container ID from /proc/self/mountinfo or hostname
    let container_id = read_container_id().ok_or_else(|| {
        "Could not determine container ID from /proc/self/mountinfo or hostname. This feature requires running in a standard Docker environment.".to_string()
    })?;

    info!("[config] sending restart request for container {}", container_id);

    // Use curl to talk to the Docker socket
    let result = Command::new("curl")
        .args([
            "--unix-socket", socket_path,
            "-X", "POST",
            &format!("http://localhost/containers/{}/restart", container_id),
        ])
        .output();

    match result {
        Ok(output) if output.status.success() => {
            info!("[config] container restart request sent successfully");
            Ok(())
        }
        Ok(output) => {
            let stderr = String::from_utf8_lossy(&output.stderr);
            let stdout = String::from_utf8_lossy(&output.stdout);
            error!(
                "[config] container restart failed: stdout={}, stderr={}",
                stdout, stderr
            );
            Err(format!("Container restart failed: {} {}", stdout, stderr))
        }
        Err(e) => {
            error!("[config] failed to send container restart request: {}", e);
            Err(format!("Failed to send restart request: {}", e))
        }
    }
}

fn read_container_id() -> Option<String> {
    // Try /proc/self/mountinfo (works in most Docker environments)
    if let Ok(content) = fs::read_to_string("/proc/self/mountinfo") {
        for line in content.lines() {
            // Look for docker container ID pattern in mount paths
            if let Some(id) = extract_container_id_from_path(line) {
                debug!("[config] found container ID from mountinfo: {}", id);
                return Some(id);
            }
        }
    }

    // Try hostname as fallback (Docker sets hostname to the short 12-char container ID by default;
    // the Docker API accepts short ID prefixes for container identification)
    if let Ok(hostname) = fs::read_to_string("/etc/hostname") {
        let hostname = hostname.trim().to_string();
        if hostname.len() == 12 && hostname.chars().all(|c| c.is_ascii_hexdigit()) {
            debug!("[config] using hostname as container ID: {}", hostname);
            return Some(hostname);
        }
    }

    // Try HOSTNAME env var
    if let Ok(hostname) = std::env::var("HOSTNAME") {
        let hostname = hostname.trim().to_string();
        if hostname.len() == 12 && hostname.chars().all(|c| c.is_ascii_hexdigit()) {
            debug!("[config] using HOSTNAME env var as container ID: {}", hostname);
            return Some(hostname);
        }
    }

    None
}

fn extract_container_id_from_path(line: &str) -> Option<String> {
    // Look for /docker/<container_id> pattern in mountinfo
    for part in line.split('/') {
        // Container IDs are 64 hex characters
        if part.len() == 64 && part.chars().all(|c| c.is_ascii_hexdigit()) {
            return Some(part.to_string());
        }
    }
    None
}

#[cfg(test)]
mod tests {
    use super::normalize_virtual_alias_source;
    use super::extract_container_id_from_path;
    use super::load_template;

    #[test]
    fn normalize_virtual_alias_source_rewrites_catch_all_patterns() {
        assert_eq!(
            normalize_virtual_alias_source("*@example.com", Some("example.com")),
            "@example.com"
        );
        assert_eq!(
            normalize_virtual_alias_source("*", Some("example.com")),
            "@example.com"
        );
        assert_eq!(
            normalize_virtual_alias_source("info@example.com", Some("example.com")),
            "info@example.com"
        );
        assert_eq!(normalize_virtual_alias_source("*", None), "*");
    }

    #[test]
    fn extract_container_id_from_mountinfo_line() {
        let line = "1234 5678 0:123 / /sys/fs/cgroup rw - cgroup2 /docker/abc123def456abc123def456abc123def456abc123def456abc123def456abcd";
        let result = extract_container_id_from_path(line);
        assert_eq!(
            result,
            Some("abc123def456abc123def456abc123def456abc123def456abc123def456abcd".to_string())
        );
    }

    #[test]
    fn extract_container_id_returns_none_for_no_id() {
        let line = "some random text without container ids";
        assert_eq!(extract_container_id_from_path(line), None);
    }

    #[test]
    fn extract_container_id_ignores_short_hex() {
        let line = "/docker/abc123 something";
        assert_eq!(extract_container_id_from_path(line), None);
    }

    #[test]
    fn master_cf_template_includes_smtp_unix_transport() {
        let template = load_template("postfix-master.cf.txt")
            .expect("postfix-master.cf.txt template should be loadable");
        assert!(
            template.contains("smtp      unix  -       -       n       -       -       smtp"),
            "master.cf template must include the smtp unix transport for outbound mail delivery"
        );
    }

    #[test]
    fn sender_login_maps_normalizes_wildcard_sources() {
        // Postfix smtpd_sender_login_maps uses @domain format for wildcard lookups.
        // Wildcard alias sources stored as *@domain must be normalized to @domain.
        assert_eq!(
            normalize_virtual_alias_source("*@gordarg.com", None),
            "@gordarg.com"
        );
        assert_eq!(
            normalize_virtual_alias_source("*@tyyi.net", None),
            "@tyyi.net"
        );
        // Specific addresses must remain unchanged
        assert_eq!(
            normalize_virtual_alias_source("info@gordarg.com", None),
            "info@gordarg.com"
        );
        assert_eq!(
            normalize_virtual_alias_source("m@tyyi.net", None),
            "m@tyyi.net"
        );
    }

    #[test]
    fn main_cf_template_exports_database_url_to_filter_subprocess() {
        let template = load_template("postfix-main.cf.txt")
            .expect("postfix-main.cf.txt template should be loadable");
        assert!(
            template.contains("export_environment") && template.contains("DATABASE_URL"),
            "main.cf template must export DATABASE_URL so the pipe filter subprocess can connect to the database"
        );
    }

    #[test]
    fn main_cf_template_does_not_set_smtpd_tls_auth_only_globally() {
        // smtpd_tls_auth_only=yes must NOT be set globally in main.cf.
        // It hides AUTH in the first EHLO response on all ports, causing email clients
        // to report "does not support the selected authentication method" when they
        // check capabilities before STARTTLS.  The per-port overrides in master.cf
        // handle this correctly: submission/smtps set it to no (AUTH always visible),
        // while plain SMTP ports (25, 2525) set it to yes (TLS is optional there).
        let template = load_template("postfix-main.cf.txt")
            .expect("postfix-main.cf.txt template should be loadable");
        assert!(
            !template.contains("smtpd_tls_auth_only"),
            "main.cf must not set smtpd_tls_auth_only globally; it is controlled per-port in master.cf"
        );
    }

    #[test]
    fn master_cf_submission_and_smtps_set_tls_auth_only_no() {
        // The submission (587) and smtps (465) ports must advertise AUTH in their
        // EHLO response regardless of whether STARTTLS has been negotiated.
        // smtpd_tls_security_level=encrypt / smtpd_tls_wrappermode=yes already
        // enforce TLS before any credentials are accepted, so advertising AUTH
        // early is safe and necessary for clients that inspect the first EHLO.
        let template = load_template("postfix-master.cf.txt")
            .expect("postfix-master.cf.txt template should be loadable");
        // submission (587): needs both encrypt enforcement and the explicit no override
        assert!(
            template.contains("smtpd_tls_security_level=encrypt")
                && template.contains("-o smtpd_tls_auth_only=no"),
            "master.cf submission entry must contain smtpd_tls_auth_only=no so AUTH is advertised in first EHLO"
        );
        // smtps (465): needs both wrappermode and the explicit no override
        assert!(
            template.contains("smtpd_tls_wrappermode=yes")
                && template.contains("-o smtpd_tls_auth_only=no"),
            "master.cf smtps entry must contain smtpd_tls_auth_only=no so AUTH is advertised immediately"
        );
        // Both ports must have the override: verify there are exactly two occurrences
        let count = template.matches("-o smtpd_tls_auth_only=no").count();
        assert_eq!(
            count, 2,
            "smtpd_tls_auth_only=no must appear exactly once for submission and once for smtps (found {})",
            count
        );
    }

    #[test]
    fn master_cf_plain_smtp_ports_set_tls_auth_only_yes() {
        // Port 25 (smtp) and 2525 (smtp-alt) use optional TLS (smtpd_tls_security_level=may).
        // On these ports AUTH must stay hidden until STARTTLS is complete so that
        // credentials are never sent over an unencrypted connection.
        let template = load_template("postfix-master.cf.txt")
            .expect("postfix-master.cf.txt template should be loadable");
        assert!(
            template.contains("-o smtpd_tls_auth_only=yes"),
            "master.cf plain SMTP ports (25/2525) must set smtpd_tls_auth_only=yes to protect credentials on optional-TLS listeners"
        );
    }
}

// ── Certificate and DH parameter generation ──

pub fn generate_tls_certificate(hostname: &str, force: bool) -> Result<(), String> {
    let cert_path = "/data/ssl/cert.pem";
    let key_path = "/data/ssl/key.pem";
    if !force
        && Path::new(cert_path).exists()
        && Path::new(key_path).exists()
        && fs::read(cert_path).map(|c| !c.is_empty()).unwrap_or(false)
        && fs::read(key_path).map(|c| !c.is_empty()).unwrap_or(false)
    {
        info!("[config] existing TLS certificate and key found, skipping certificate generation");
        return Ok(());
    }
    info!("[config] generating self-signed TLS certificate for hostname={}", hostname);
    
    // Sanitize hostname for use in certificate subject
    let safe_hostname: String = hostname.chars()
        .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-')
        .collect();
    
    if safe_hostname.is_empty() {
        return Err("hostname is empty or contains only invalid characters".to_string());
    }
    
    // Create SSL directory if it doesn't exist
    if let Err(e) = fs::create_dir_all("/data/ssl") {
        error!("[config] failed to create /data/ssl directory: {}", e);
        return Err(format!("failed to create SSL directory: {}", e));
    }
    
    // Create OpenSSL config file with SAN extension
    // Modern TLS clients require Subject Alternative Name (SAN) to be present
    let openssl_config = format!(
        "[req]\n\
         default_bits = 2048\n\
         prompt = no\n\
         default_md = sha256\n\
         distinguished_name = dn\n\
         x509_extensions = v3_req\n\
         \n\
         [dn]\n\
         CN = {}\n\
         \n\
         [v3_req]\n\
         subjectAltName = @alt_names\n\
         \n\
         [alt_names]\n\
         DNS.1 = {}\n\
         DNS.2 = localhost\n\
         IP.1 = 127.0.0.1\n",
        safe_hostname, safe_hostname
    );
    
    // Use a unique temporary file to avoid race conditions
    // Note: In Docker container context, /tmp is isolated and single-process
    let uuid = uuid::Uuid::new_v4();
    let config_path = format!("/tmp/openssl-cert-{}.cnf", uuid);
    
    if let Err(e) = fs::write(&config_path, &openssl_config) {
        error!("[config] failed to write OpenSSL config file: {}", e);
        return Err(format!("failed to write OpenSSL config: {}", e));
    }
    
    // Generate certificate with SAN extension
    let result = Command::new("openssl")
        .args([
            "req", "-new", "-newkey", "rsa:2048", "-days", "3650",
            "-nodes", "-x509",
            "-config", &config_path,
            "-keyout", "/data/ssl/key.pem",
            "-out", "/data/ssl/cert.pem",
        ])
        .output();
    
    // Clean up config file
    if let Err(e) = fs::remove_file(&config_path) {
        warn!("[config] failed to clean up temporary OpenSSL config file: {}", e);
    }
    
    match result {
        Ok(output) if output.status.success() => {
            // Set secure permissions on the private key
            match Command::new("chmod").args(["600", "/data/ssl/key.pem"]).output() {
                Ok(o) if o.status.success() => debug!("[config] set key.pem permissions to 600"),
                Ok(o) => warn!("[config] chmod 600 key.pem exited with status {}", o.status),
                Err(e) => warn!("[config] failed to set key.pem permissions: {}", e),
            }
            info!("[config] TLS certificate with SAN generated successfully");
            Ok(())
        }
        Ok(output) => {
            let stderr = String::from_utf8_lossy(&output.stderr);
            error!("[config] openssl failed: {}", stderr);
            Err(format!("openssl failed: {}", stderr))
        }
        Err(e) => {
            error!("[config] failed to run openssl: {}", e);
            Err(format!("failed to run openssl: {}", e))
        }
    }
}

pub fn generate_dh_parameters() -> Result<(), String> {
    let dh_path = "/usr/share/dovecot/dh.pem";
    
    // Check if DH parameters already exist
    if Path::new(dh_path).exists() {
        info!("[config] DH parameters already exist at {}, skipping generation", dh_path);
        return Ok(());
    }
    
    info!("[config] generating Diffie-Hellman parameters (this may take a while)");
    
    // Create dovecot directory if it doesn't exist
    if let Err(e) = fs::create_dir_all("/usr/share/dovecot") {
        error!("[config] failed to create /usr/share/dovecot directory: {}", e);
        return Err(format!("failed to create directory: {}", e));
    }
    
    // Generate DH parameters
    let result = Command::new("openssl")
        .args(["dhparam", "-out", dh_path, "2048"])
        .output();
    
    match result {
        Ok(output) if output.status.success() => {
            info!("[config] DH parameters generated successfully");
            Ok(())
        }
        Ok(output) => {
            let stderr = String::from_utf8_lossy(&output.stderr);
            error!("[config] openssl dhparam failed: {}", stderr);
            Err(format!("openssl dhparam failed: {}", stderr))
        }
        Err(e) => {
            error!("[config] failed to run openssl dhparam: {}", e);
            Err(format!("failed to run openssl dhparam: {}", e))
        }
    }
}

pub fn generate_all_certificates(hostname: &str, force: bool) -> Result<(), String> {
    info!("[config] generating all certificates and DH parameters for hostname={}", hostname);
    
    // Generate TLS certificate
    generate_tls_certificate(hostname, force)?;
    
    // Generate DH parameters
    generate_dh_parameters()?;
    
    info!("[config] all certificates and DH parameters generated successfully");
    Ok(())
}
