use crate::db::Database;
use log::{debug, error, info, warn};
use std::fs;
use std::path::Path;
use std::process::Command;

// ── Template Loading ──

fn load_template(filename: &str) -> std::io::Result<String> {
    // Try to load from templates/config directory
    let paths = vec![
        format!("templates/config/{}", filename),
        format!("/app/templates/config/{}", filename),
    ];

    for path in paths {
        if Path::new(&path).exists() {
            debug!("[config] loading template from {}", path);
            return fs::read_to_string(path);
        }
    }

    Err(std::io::Error::new(
        std::io::ErrorKind::NotFound,
        format!("Template {} not found in any template directory", filename),
    ))
}

fn safe_filename(name: &str) -> String {
    name.chars()
        .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-')
        .collect()
}

pub fn generate_all_configs(db: &Database, hostname: &str) {
    info!(
        "[config] generating all configuration files for hostname={}",
        hostname
    );
    generate_postfix_main_cf(hostname);
    generate_postfix_master_cf();
    generate_virtual_domains(db);
    generate_virtual_mailboxes(db);
    generate_virtual_aliases(db);
    generate_sender_login_maps(db);
    generate_dovecot_conf(hostname);
    generate_dovecot_passwd(db);
    generate_opendkim_conf();
    generate_opendkim_tables(db);
    postmap_files();
    reload_services();
    info!("[config] all configuration files generated successfully");
}

pub fn generate_postfix_main_cf(hostname: &str) {
    info!(
        "[config] generating /etc/postfix/main.cf for hostname={}",
        hostname
    );
    let mydomain = hostname.splitn(2, '.').nth(1).unwrap_or(hostname);

    let template = load_template("postfix-main.cf.txt").expect("postfix-main.cf.txt template not found");

    let config = template
        .replace("{{ hostname }}", hostname)
        .replace("{{ mydomain }}", mydomain);

    match fs::write("/etc/postfix/main.cf", config) {
        Ok(_) => debug!("[config] wrote /etc/postfix/main.cf"),
        Err(e) => error!("[config] failed to write /etc/postfix/main.cf: {}", e),
    }
}

pub fn generate_postfix_master_cf() {
    info!("[config] generating /etc/postfix/master.cf");
    let config = load_template("postfix-master.cf.txt").expect("postfix-master.cf.txt template not found");

    match fs::write("/etc/postfix/master.cf", config) {
        Ok(_) => debug!("[config] wrote /etc/postfix/master.cf"),
        Err(e) => error!("[config] failed to write /etc/postfix/master.cf: {}", e),
    }
}

pub fn generate_virtual_domains(db: &Database) {
    info!("[config] generating /etc/postfix/virtual_domains");
    let domains = db.list_domains();
    let mut lines = String::from("# Generated by mailserver\n");
    for d in &domains {
        if d.active {
            lines.push_str(&format!("{} OK\n", d.domain));
        }
    }
    match fs::write("/etc/postfix/virtual_domains", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/virtual_domains ({} domains)",
            domains.len()
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/virtual_domains: {}",
            e
        ),
    }
}

pub fn generate_virtual_mailboxes(db: &Database) {
    info!("[config] generating /etc/postfix/vmailbox");
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = String::from("# Generated by mailserver\n");
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{} {}/{}/Maildir/\n",
                a.username, domain, domain, a.username
            ));
        }
    }
    match fs::write("/etc/postfix/vmailbox", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/vmailbox ({} accounts)",
            accounts.len()
        ),
        Err(e) => error!("[config] failed to write /etc/postfix/vmailbox: {}", e),
    }
}

pub fn generate_virtual_aliases(db: &Database) {
    info!("[config] generating /etc/postfix/virtual_aliases");
    let aliases = db.list_all_aliases_with_domain();
    let mut lines = String::from("# Generated by mailserver\n");
    for a in &aliases {
        if a.active {
            lines.push_str(&format!("{} {}\n", a.source, a.destination));
        }
    }
    match fs::write("/etc/postfix/virtual_aliases", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/virtual_aliases ({} aliases)",
            aliases.len()
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/virtual_aliases: {}",
            e
        ),
    }
}

pub fn generate_sender_login_maps(db: &Database) {
    info!("[config] generating /etc/postfix/sender_login_maps");
    let entries = db.get_sender_login_map();

    // Group by alias source: each alias source maps to all account emails on the same domain
    let mut map: std::collections::HashMap<String, Vec<String>> = std::collections::HashMap::new();
    for (alias_source, account_email) in &entries {
        map.entry(alias_source.clone())
            .or_default()
            .push(account_email.clone());
    }

    // Also allow each account to send as itself
    let accounts = db.list_all_accounts_with_domain();
    for a in &accounts {
        if a.active {
            if let Some(ref domain) = a.domain_name {
                let email = format!("{}@{}", a.username, domain);
                map.entry(email.clone()).or_default().push(email);
            }
        }
    }

    let mut lines = String::from("# Generated by mailserver\n");
    for (sender, logins) in &map {
        // Deduplicate logins
        let mut unique: Vec<&String> = logins.iter().collect();
        unique.sort();
        unique.dedup();
        lines.push_str(&format!(
            "{} {}\n",
            sender,
            unique
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<_>>()
                .join(",")
        ));
    }
    match fs::write("/etc/postfix/sender_login_maps", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/sender_login_maps ({} entries)",
            map.len()
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/sender_login_maps: {}",
            e
        ),
    }
}

pub fn generate_dovecot_conf(hostname: &str) {
    info!(
        "[config] generating /etc/dovecot/dovecot.conf for hostname={}",
        hostname
    );
    let template = load_template("dovecot.conf.txt").expect("dovecot.conf.txt template not found");

    let config = template.replace("{{ hostname }}", hostname);

    match fs::write("/etc/dovecot/dovecot.conf", config) {
        Ok(_) => debug!("[config] wrote /etc/dovecot/dovecot.conf"),
        Err(e) => error!("[config] failed to write /etc/dovecot/dovecot.conf: {}", e),
    }
}

pub fn generate_dovecot_passwd(db: &Database) {
    info!("[config] generating /etc/dovecot/passwd");
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = String::new();
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{}:{{BLF-CRYPT}}{}:::::\n",
                a.username, domain, a.password_hash
            ));
        }
    }
    match fs::write("/etc/dovecot/passwd", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/dovecot/passwd ({} accounts)",
            accounts.len()
        ),
        Err(e) => error!("[config] failed to write /etc/dovecot/passwd: {}", e),
    }
}

pub fn generate_opendkim_conf() {
    info!("[config] generating /etc/opendkim/opendkim.conf");
    let config = load_template("opendkim.conf.txt").expect("opendkim.conf.txt template not found");

    match fs::write("/etc/opendkim/opendkim.conf", config) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/opendkim.conf"),
        Err(e) => error!(
            "[config] failed to write /etc/opendkim/opendkim.conf: {}",
            e
        ),
    }
}

pub fn generate_opendkim_tables(db: &Database) {
    info!("[config] generating OpenDKIM key/signing/trusted tables");
    let domains = db.list_domains();

    let mut key_table = String::from("# Generated by mailserver\n");
    let mut signing_table = String::from("# Generated by mailserver\n");
    let mut trusted_hosts = String::from("# Generated by mailserver\n127.0.0.1\nlocalhost\n");
    let mut dkim_count: usize = 0;

    for d in &domains {
        if !d.active {
            debug!("[config] skipping inactive domain {} for DKIM", d.domain);
            continue;
        }
        if let Some(ref private_key) = d.dkim_private_key {
            let selector = &d.dkim_selector;
            let domain = &d.domain;
            let key_path = format!("/data/dkim/{}.private", safe_filename(domain));

            // Write the private key file
            if let Err(e) = fs::create_dir_all("/data/dkim") {
                error!("[config] failed to create /data/dkim directory: {}", e);
            }
            match fs::write(&key_path, private_key) {
                Ok(_) => debug!(
                    "[config] wrote DKIM private key for domain={} to {}",
                    domain, key_path
                ),
                Err(e) => error!(
                    "[config] failed to write DKIM private key for domain={}: {}",
                    domain, e
                ),
            }

            key_table.push_str(&format!(
                "{}._domainkey.{} {}:{}:{}\n",
                selector, domain, domain, selector, key_path
            ));
            signing_table.push_str(&format!(
                "*@{} {}._domainkey.{}\n",
                domain, selector, domain
            ));
            trusted_hosts.push_str(&format!("{}\n", domain));
            dkim_count += 1;
        } else {
            debug!("[config] domain {} has no DKIM key configured", d.domain);
        }
    }

    info!(
        "[config] writing OpenDKIM tables ({} DKIM-enabled domains)",
        dkim_count
    );
    match fs::write("/etc/opendkim/KeyTable", key_table) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/KeyTable"),
        Err(e) => error!("[config] failed to write /etc/opendkim/KeyTable: {}", e),
    }
    match fs::write("/etc/opendkim/SigningTable", signing_table) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/SigningTable"),
        Err(e) => error!("[config] failed to write /etc/opendkim/SigningTable: {}", e),
    }
    match fs::write("/etc/opendkim/TrustedHosts", trusted_hosts) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/TrustedHosts"),
        Err(e) => error!("[config] failed to write /etc/opendkim/TrustedHosts: {}", e),
    }
}

pub fn postmap_files() {
    info!("[config] running postmap on virtual maps");
    for path in &[
        "/etc/postfix/virtual_domains",
        "/etc/postfix/vmailbox",
        "/etc/postfix/virtual_aliases",
        "/etc/postfix/sender_login_maps",
    ] {
        // Explicitly specify lmdb format for Alpine Linux compatibility
        let lmdb_path = format!("lmdb:{}", path);
        match Command::new("postmap").arg(&lmdb_path).output() {
            Ok(output) if output.status.success() => {
                debug!("[config] postmap succeeded for {}", lmdb_path);
            }
            Ok(output) => {
                warn!(
                    "[config] postmap for {} exited with status {}: {}",
                    lmdb_path,
                    output.status,
                    String::from_utf8_lossy(&output.stderr)
                );
            }
            Err(e) => {
                warn!("[config] failed to run postmap for {}: {}", lmdb_path, e);
            }
        }
    }
}

pub fn reload_services() {
    info!("[config] reloading mail services");

    match Command::new("postfix").arg("reload").output() {
        Ok(output) if output.status.success() => info!("[config] postfix reloaded successfully"),
        Ok(output) => warn!(
            "[config] postfix reload exited with status {}: {}",
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ),
        Err(e) => warn!("[config] failed to reload postfix: {}", e),
    }

    match Command::new("dovecot").arg("reload").output() {
        Ok(output) if output.status.success() => info!("[config] dovecot reloaded successfully"),
        Ok(output) => warn!(
            "[config] dovecot reload exited with status {}: {}",
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ),
        Err(e) => warn!("[config] failed to reload dovecot: {}", e),
    }

    // Signal opendkim to reload via USR1
    match Command::new("pgrep").arg("opendkim").output() {
        Ok(output) => {
            let pids = String::from_utf8_lossy(&output.stdout);
            for pid in pids.split_whitespace() {
                match Command::new("kill").args(["-USR1", pid]).output() {
                    Ok(_) => debug!("[config] sent USR1 to opendkim pid={}", pid),
                    Err(e) => warn!("[config] failed to signal opendkim pid={}: {}", pid, e),
                }
            }
            if pids.trim().is_empty() {
                debug!("[config] no opendkim process found to signal");
            }
        }
        Err(e) => warn!("[config] failed to find opendkim process: {}", e),
    }

    info!("[config] service reload complete");
}

// ── Certificate and DH parameter generation ──

pub fn generate_tls_certificate(hostname: &str) -> Result<(), String> {
    if Path::new("/data/ssl/cert.pem").exists()
        && Path::new("/data/ssl/key.pem").exists()
        && fs::read("/data/ssl/cert.pem")
            .map(|content| !content.is_empty())
            .unwrap_or(false)
        && fs::read("/data/ssl/key.pem")
            .map(|content| !content.is_empty())
            .unwrap_or(false)
    {
        info!("[config] existing TLS certificate and key found, skipping certificate generation");
        return Ok(());
    }
    info!("[config] generating self-signed TLS certificate for hostname={}", hostname);
    
    // Sanitize hostname for use in certificate subject
    let safe_hostname: String = hostname.chars()
        .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-')
        .collect();
    
    if safe_hostname.is_empty() {
        return Err("hostname is empty or contains only invalid characters".to_string());
    }
    
    // Create SSL directory if it doesn't exist
    if let Err(e) = fs::create_dir_all("/data/ssl") {
        error!("[config] failed to create /data/ssl directory: {}", e);
        return Err(format!("failed to create SSL directory: {}", e));
    }
    
    // Create OpenSSL config file with SAN extension
    // Modern TLS clients require Subject Alternative Name (SAN) to be present
    let openssl_config = format!(
        "[req]\n\
         default_bits = 2048\n\
         prompt = no\n\
         default_md = sha256\n\
         distinguished_name = dn\n\
         x509_extensions = v3_req\n\
         \n\
         [dn]\n\
         CN = {}\n\
         \n\
         [v3_req]\n\
         subjectAltName = @alt_names\n\
         \n\
         [alt_names]\n\
         DNS.1 = {}\n\
         DNS.2 = localhost\n\
         IP.1 = 127.0.0.1\n",
        safe_hostname, safe_hostname
    );
    
    // Use a unique temporary file to avoid race conditions
    // Note: In Docker container context, /tmp is isolated and single-process
    let uuid = uuid::Uuid::new_v4();
    let config_path = format!("/tmp/openssl-cert-{}.cnf", uuid);
    
    if let Err(e) = fs::write(&config_path, &openssl_config) {
        error!("[config] failed to write OpenSSL config file: {}", e);
        return Err(format!("failed to write OpenSSL config: {}", e));
    }
    
    // Generate certificate with SAN extension
    let result = Command::new("openssl")
        .args([
            "req", "-new", "-newkey", "rsa:2048", "-days", "3650",
            "-nodes", "-x509",
            "-config", &config_path,
            "-keyout", "/data/ssl/key.pem",
            "-out", "/data/ssl/cert.pem",
        ])
        .output();
    
    // Clean up config file
    if let Err(e) = fs::remove_file(&config_path) {
        warn!("[config] failed to clean up temporary OpenSSL config file: {}", e);
    }
    
    match result {
        Ok(output) if output.status.success() => {
            // Set secure permissions on the private key
            match Command::new("chmod").args(["600", "/data/ssl/key.pem"]).output() {
                Ok(o) if o.status.success() => debug!("[config] set key.pem permissions to 600"),
                Ok(o) => warn!("[config] chmod 600 key.pem exited with status {}", o.status),
                Err(e) => warn!("[config] failed to set key.pem permissions: {}", e),
            }
            info!("[config] TLS certificate with SAN generated successfully");
            Ok(())
        }
        Ok(output) => {
            let stderr = String::from_utf8_lossy(&output.stderr);
            error!("[config] openssl failed: {}", stderr);
            Err(format!("openssl failed: {}", stderr))
        }
        Err(e) => {
            error!("[config] failed to run openssl: {}", e);
            Err(format!("failed to run openssl: {}", e))
        }
    }
}

pub fn generate_dh_parameters() -> Result<(), String> {
    let dh_path = "/usr/share/dovecot/dh.pem";
    
    // Check if DH parameters already exist
    if Path::new(dh_path).exists() {
        info!("[config] DH parameters already exist at {}, skipping generation", dh_path);
        return Ok(());
    }
    
    info!("[config] generating Diffie-Hellman parameters (this may take a while)");
    
    // Create dovecot directory if it doesn't exist
    if let Err(e) = fs::create_dir_all("/usr/share/dovecot") {
        error!("[config] failed to create /usr/share/dovecot directory: {}", e);
        return Err(format!("failed to create directory: {}", e));
    }
    
    // Generate DH parameters
    let result = Command::new("openssl")
        .args(["dhparam", "-out", dh_path, "2048"])
        .output();
    
    match result {
        Ok(output) if output.status.success() => {
            info!("[config] DH parameters generated successfully");
            Ok(())
        }
        Ok(output) => {
            let stderr = String::from_utf8_lossy(&output.stderr);
            error!("[config] openssl dhparam failed: {}", stderr);
            Err(format!("openssl dhparam failed: {}", stderr))
        }
        Err(e) => {
            error!("[config] failed to run openssl dhparam: {}", e);
            Err(format!("failed to run openssl dhparam: {}", e))
        }
    }
}

pub fn generate_all_certificates(hostname: &str) -> Result<(), String> {
    info!("[config] generating all certificates and DH parameters for hostname={}", hostname);
    
    // Generate TLS certificate
    generate_tls_certificate(hostname)?;
    
    // Generate DH parameters
    generate_dh_parameters()?;
    
    info!("[config] all certificates and DH parameters generated successfully");
    Ok(())
}
