use crate::db::Database;
use log::{info, warn, error, debug};
use std::fs;
use std::process::Command;

fn safe_filename(name: &str) -> String {
    name.chars()
        .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-')
        .collect()
}

pub fn generate_all_configs(db: &Database, hostname: &str) {
    info!("[config] generating all configuration files for hostname={}", hostname);
    generate_postfix_main_cf(hostname);
    generate_postfix_master_cf();
    generate_virtual_domains(db);
    generate_virtual_mailboxes(db);
    generate_virtual_aliases(db);
    generate_dovecot_conf(hostname);
    generate_dovecot_passwd(db);
    generate_opendkim_conf();
    generate_opendkim_tables(db);
    postmap_files();
    reload_services();
    info!("[config] all configuration files generated successfully");
}

pub fn generate_postfix_main_cf(hostname: &str) {
    info!("[config] generating /etc/postfix/main.cf for hostname={}", hostname);
    let mydomain = hostname.splitn(2, '.').nth(1).unwrap_or(hostname);

    let config = format!(
        r#"# Generated by mailserver
myhostname = {hostname}
mydomain = {mydomain}
myorigin = $mydomain
mydestination = localhost
inet_interfaces = all
inet_protocols = all

# Virtual mailbox delivery via Dovecot LMTP
virtual_transport = lmtp:inet:localhost:24
virtual_mailbox_domains = hash:/etc/postfix/virtual_domains
virtual_mailbox_maps = hash:/etc/postfix/vmailbox
virtual_alias_maps = hash:/etc/postfix/virtual_aliases

# SASL auth via Dovecot
smtpd_sasl_type = dovecot
smtpd_sasl_path = inet:localhost:12345
smtpd_sasl_auth_enable = yes
smtpd_sasl_security_options = noanonymous

# TLS
smtpd_tls_cert_file = /data/ssl/cert.pem
smtpd_tls_key_file = /data/ssl/key.pem
smtpd_tls_security_level = may
smtpd_tls_auth_only = yes
smtp_tls_security_level = may

# Milters
smtpd_milters = inet:localhost:8891
non_smtpd_milters = inet:localhost:8891
milter_default_action = accept

# Content filter for pixel injection
content_filter = pixelfilter:dummy

# Restrictions
smtpd_recipient_restrictions = permit_sasl_authenticated, permit_mynetworks, reject_unauth_destination

# Limits
message_size_limit = 31457280
"#,
        hostname = hostname,
        mydomain = mydomain,
    );

    match fs::write("/etc/postfix/main.cf", config) {
        Ok(_) => debug!("[config] wrote /etc/postfix/main.cf"),
        Err(e) => error!("[config] failed to write /etc/postfix/main.cf: {}", e),
    }
}

pub fn generate_postfix_master_cf() {
    info!("[config] generating /etc/postfix/master.cf");
    let config = r#"# Generated by mailserver
# ==========================================================================
# service type  private unpriv  chroot  wakeup  maxproc command + args
# ==========================================================================
smtp      inet  n       -       n       -       -       smtpd
submission inet  n       -       n       -       -       smtpd
  -o syslog_name=postfix/submission
  -o smtpd_tls_security_level=encrypt
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_sasl_type=dovecot
  -o smtpd_sasl_path=inet:localhost:12345
  -o smtpd_recipient_restrictions=permit_sasl_authenticated,reject
smtps     inet  n       -       n       -       -       smtpd
  -o syslog_name=postfix/smtps
  -o smtpd_tls_wrappermode=yes
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_sasl_type=dovecot
  -o smtpd_sasl_path=inet:localhost:12345
  -o smtpd_recipient_restrictions=permit_sasl_authenticated,reject
127.0.0.1:10025 inet n  -       n       -       -       smtpd
  -o content_filter=
  -o receive_override_options=no_unknown_recipient_checks,no_header_body_checks
  -o smtpd_recipient_restrictions=permit_mynetworks,reject
pixelfilter unix -      n       n       -       10      pipe
  flags=Rq user=nobody argv=/usr/local/bin/mailserver filter -f ${sender} -- ${recipient}
lmtp      unix  -       -       n       -       -       lmtp
"#;

    match fs::write("/etc/postfix/master.cf", config) {
        Ok(_) => debug!("[config] wrote /etc/postfix/master.cf"),
        Err(e) => error!("[config] failed to write /etc/postfix/master.cf: {}", e),
    }
}

pub fn generate_virtual_domains(db: &Database) {
    info!("[config] generating /etc/postfix/virtual_domains");
    let domains = db.list_domains();
    let mut lines = String::from("# Generated by mailserver\n");
    for d in &domains {
        if d.active {
            lines.push_str(&format!("{} OK\n", d.domain));
        }
    }
    match fs::write("/etc/postfix/virtual_domains", lines) {
        Ok(_) => debug!("[config] wrote /etc/postfix/virtual_domains ({} domains)", domains.len()),
        Err(e) => error!("[config] failed to write /etc/postfix/virtual_domains: {}", e),
    }
}

pub fn generate_virtual_mailboxes(db: &Database) {
    info!("[config] generating /etc/postfix/vmailbox");
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = String::from("# Generated by mailserver\n");
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{} {}/{}/Maildir/\n",
                a.username, domain, domain, a.username
            ));
        }
    }
    match fs::write("/etc/postfix/vmailbox", lines) {
        Ok(_) => debug!("[config] wrote /etc/postfix/vmailbox ({} accounts)", accounts.len()),
        Err(e) => error!("[config] failed to write /etc/postfix/vmailbox: {}", e),
    }
}

pub fn generate_virtual_aliases(db: &Database) {
    info!("[config] generating /etc/postfix/virtual_aliases");
    let aliases = db.list_all_aliases_with_domain();
    let mut lines = String::from("# Generated by mailserver\n");
    for a in &aliases {
        if a.active {
            lines.push_str(&format!("{} {}\n", a.source, a.destination));
        }
    }
    match fs::write("/etc/postfix/virtual_aliases", lines) {
        Ok(_) => debug!("[config] wrote /etc/postfix/virtual_aliases ({} aliases)", aliases.len()),
        Err(e) => error!("[config] failed to write /etc/postfix/virtual_aliases: {}", e),
    }
}

pub fn generate_dovecot_conf(hostname: &str) {
    info!("[config] generating /etc/dovecot/dovecot.conf for hostname={}", hostname);
    let config = format!(
        r#"# Generated by mailserver
protocols = imap pop3 lmtp
hostname = {hostname}

mail_location = maildir:/data/mail/%d/%n/Maildir

ssl = required
ssl_cert = </data/ssl/cert.pem
ssl_key = </data/ssl/key.pem

passdb {{
  driver = passwd-file
  args = /etc/dovecot/passwd
}}

userdb {{
  driver = static
  args = uid=vmail gid=vmail home=/data/mail/%d/%n
}}

service auth {{
  inet_listener sasl {{
    port = 12345
  }}
}}

service lmtp {{
  inet_listener lmtp {{
    port = 24
  }}
}}

namespace inbox {{
  inbox = yes

  mailbox Sent {{
    auto = subscribe
    special_use = \Sent
  }}

  mailbox Drafts {{
    auto = subscribe
    special_use = \Drafts
  }}

  mailbox Trash {{
    auto = subscribe
    special_use = \Trash
  }}

  mailbox Junk {{
    auto = subscribe
    special_use = \Junk
  }}
}}
"#,
        hostname = hostname,
    );

    match fs::write("/etc/dovecot/dovecot.conf", config) {
        Ok(_) => debug!("[config] wrote /etc/dovecot/dovecot.conf"),
        Err(e) => error!("[config] failed to write /etc/dovecot/dovecot.conf: {}", e),
    }
}

pub fn generate_dovecot_passwd(db: &Database) {
    info!("[config] generating /etc/dovecot/passwd");
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = String::new();
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{}:{{BLF-CRYPT}}{}:::::\n",
                a.username, domain, a.password_hash
            ));
        }
    }
    match fs::write("/etc/dovecot/passwd", lines) {
        Ok(_) => debug!("[config] wrote /etc/dovecot/passwd ({} accounts)", accounts.len()),
        Err(e) => error!("[config] failed to write /etc/dovecot/passwd: {}", e),
    }
}

pub fn generate_opendkim_conf() {
    info!("[config] generating /etc/opendkim/opendkim.conf");
    let config = r#"# Generated by mailserver
Syslog          yes
SyslogSuccess   yes
LogWhy          yes
Mode            sv
Canonicalization relaxed/simple
KeyTable        /etc/opendkim/KeyTable
SigningTable     refile:/etc/opendkim/SigningTable
ExternalIgnoreList /etc/opendkim/TrustedHosts
InternalHosts   /etc/opendkim/TrustedHosts
Socket          inet:8891@localhost
PidFile         /run/opendkim/opendkim.pid
UserID          opendkim
UMask           007
"#;

    match fs::write("/etc/opendkim/opendkim.conf", config) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/opendkim.conf"),
        Err(e) => error!("[config] failed to write /etc/opendkim/opendkim.conf: {}", e),
    }
}

pub fn generate_opendkim_tables(db: &Database) {
    info!("[config] generating OpenDKIM key/signing/trusted tables");
    let domains = db.list_domains();

    let mut key_table = String::from("# Generated by mailserver\n");
    let mut signing_table = String::from("# Generated by mailserver\n");
    let mut trusted_hosts = String::from("# Generated by mailserver\n127.0.0.1\nlocalhost\n");
    let mut dkim_count: usize = 0;

    for d in &domains {
        if !d.active {
            debug!("[config] skipping inactive domain {} for DKIM", d.domain);
            continue;
        }
        if let Some(ref private_key) = d.dkim_private_key {
            let selector = &d.dkim_selector;
            let domain = &d.domain;
            let key_path = format!("/data/dkim/{}.private", safe_filename(domain));

            // Write the private key file
            if let Err(e) = fs::create_dir_all("/data/dkim") {
                error!("[config] failed to create /data/dkim directory: {}", e);
            }
            match fs::write(&key_path, private_key) {
                Ok(_) => debug!("[config] wrote DKIM private key for domain={} to {}", domain, key_path),
                Err(e) => error!("[config] failed to write DKIM private key for domain={}: {}", domain, e),
            }

            key_table.push_str(&format!(
                "{}._domainkey.{} {}:{}:{}\n",
                selector, domain, domain, selector, key_path
            ));
            signing_table.push_str(&format!(
                "*@{} {}._domainkey.{}\n",
                domain, selector, domain
            ));
            trusted_hosts.push_str(&format!("{}\n", domain));
            dkim_count += 1;
        } else {
            debug!("[config] domain {} has no DKIM key configured", d.domain);
        }
    }

    info!("[config] writing OpenDKIM tables ({} DKIM-enabled domains)", dkim_count);
    match fs::write("/etc/opendkim/KeyTable", key_table) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/KeyTable"),
        Err(e) => error!("[config] failed to write /etc/opendkim/KeyTable: {}", e),
    }
    match fs::write("/etc/opendkim/SigningTable", signing_table) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/SigningTable"),
        Err(e) => error!("[config] failed to write /etc/opendkim/SigningTable: {}", e),
    }
    match fs::write("/etc/opendkim/TrustedHosts", trusted_hosts) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/TrustedHosts"),
        Err(e) => error!("[config] failed to write /etc/opendkim/TrustedHosts: {}", e),
    }
}

pub fn postmap_files() {
    info!("[config] running postmap on virtual maps");
    for path in &[
        "/etc/postfix/virtual_domains",
        "/etc/postfix/vmailbox",
        "/etc/postfix/virtual_aliases",
    ] {
        match Command::new("postmap").arg(path).output() {
            Ok(output) if output.status.success() => {
                debug!("[config] postmap succeeded for {}", path);
            }
            Ok(output) => {
                warn!("[config] postmap for {} exited with status {}: {}", path, output.status,
                    String::from_utf8_lossy(&output.stderr));
            }
            Err(e) => {
                warn!("[config] failed to run postmap for {}: {}", path, e);
            }
        }
    }
}

pub fn reload_services() {
    info!("[config] reloading mail services");

    match Command::new("postfix").arg("reload").output() {
        Ok(output) if output.status.success() => info!("[config] postfix reloaded successfully"),
        Ok(output) => warn!("[config] postfix reload exited with status {}: {}",
            output.status, String::from_utf8_lossy(&output.stderr)),
        Err(e) => warn!("[config] failed to reload postfix: {}", e),
    }

    match Command::new("dovecot").arg("reload").output() {
        Ok(output) if output.status.success() => info!("[config] dovecot reloaded successfully"),
        Ok(output) => warn!("[config] dovecot reload exited with status {}: {}",
            output.status, String::from_utf8_lossy(&output.stderr)),
        Err(e) => warn!("[config] failed to reload dovecot: {}", e),
    }

    // Signal opendkim to reload via USR1
    match Command::new("pgrep").arg("opendkim").output() {
        Ok(output) => {
            let pids = String::from_utf8_lossy(&output.stdout);
            for pid in pids.split_whitespace() {
                match Command::new("kill").args(["-USR1", pid]).output() {
                    Ok(_) => debug!("[config] sent USR1 to opendkim pid={}", pid),
                    Err(e) => warn!("[config] failed to signal opendkim pid={}: {}", pid, e),
                }
            }
            if pids.trim().is_empty() {
                debug!("[config] no opendkim process found to signal");
            }
        }
        Err(e) => warn!("[config] failed to find opendkim process: {}", e),
    }

    info!("[config] service reload complete");
}
