use crate::db::Database;
use log::{debug, error, info, warn};
use std::fs;
use std::path::Path;
use std::process::Command;

// ── Template Loading ──

fn load_template(filename: &str) -> std::io::Result<String> {
    // Try to load from templates/config directory
    let paths = vec![
        format!("templates/config/{}", filename),
        format!("/app/templates/config/{}", filename),
    ];

    for path in paths {
        if Path::new(&path).exists() {
            debug!("[config] loading template from {}", path);
            return fs::read_to_string(path);
        }
    }

    Err(std::io::Error::new(
        std::io::ErrorKind::NotFound,
        format!("Template {} not found in any template directory", filename),
    ))
}

// ── Fallback Configuration Defaults ──

const DEFAULT_POSTFIX_MAIN_CF: &str = r#"# Generated by mailserver
myhostname = {{ hostname }}
mydomain = {{ mydomain }}
myorigin = $mydomain
mydestination = localhost
inet_interfaces = all
inet_protocols = all

# Disable local alias database (we only use virtual domains)
alias_maps =
alias_database =

# Virtual mailbox delivery via Dovecot LMTP
virtual_transport = lmtp:inet:localhost:24
virtual_mailbox_domains = lmdb:/etc/postfix/virtual_domains
virtual_mailbox_maps = lmdb:/etc/postfix/vmailbox
virtual_alias_maps = lmdb:/etc/postfix/virtual_aliases

# SASL auth via Dovecot
smtpd_sasl_type = dovecot
smtpd_sasl_path = inet:localhost:12345
smtpd_sasl_auth_enable = yes
smtpd_sasl_security_options = noanonymous

# TLS
smtpd_tls_cert_file = /data/ssl/cert.pem
smtpd_tls_key_file = /data/ssl/key.pem
smtpd_tls_security_level = may
smtpd_tls_auth_only = yes
smtp_tls_security_level = may

# Milters
smtpd_milters = inet:localhost:8891
non_smtpd_milters = inet:localhost:8891
milter_default_action = accept

# Content filter for pixel injection
content_filter = pixelfilter:dummy

# Sender login maps — allow accounts to send as their aliases
smtpd_sender_login_maps = lmdb:/etc/postfix/sender_login_maps
smtpd_sender_restrictions = reject_authenticated_sender_login_mismatch, permit

# Restrictions
smtpd_recipient_restrictions = permit_sasl_authenticated, permit_mynetworks, reject_unauth_destination

# Client restrictions - allow connections while reducing reverse DNS warnings
# Note: Many legitimate clients have incomplete reverse DNS, so we permit by default
# while maintaining other security restrictions (auth, recipient validation)
smtpd_client_restrictions = permit_mynetworks, permit_sasl_authenticated, permit
disable_vrfy_command = yes

# Limits
message_size_limit = 31457280
"#;

const DEFAULT_POSTFIX_MASTER_CF: &str = r#"# Generated by mailserver
# ==========================================================================
# service type  private unpriv  chroot  wakeup  maxproc command + args
# ==========================================================================
smtp      inet  n       -       n       -       -       smtpd
submission inet  n       -       n       -       -       smtpd
  -o syslog_name=postfix/submission
  -o smtpd_tls_security_level=encrypt
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_sasl_type=dovecot
  -o smtpd_sasl_path=inet:localhost:12345
  -o smtpd_recipient_restrictions=permit_sasl_authenticated,reject
smtps     inet  n       -       n       -       -       smtpd
  -o syslog_name=postfix/smtps
  -o smtpd_tls_wrappermode=yes
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_sasl_type=dovecot
  -o smtpd_sasl_path=inet:localhost:12345
  -o smtpd_recipient_restrictions=permit_sasl_authenticated,reject
2525      inet  n       -       n       -       -       smtpd
  -o syslog_name=postfix/smtp-alt

pickup    unix  n       -       n       60      1       pickup
cleanup   unix  n       -       n       -       0       cleanup
qmgr      unix  n       -       n       300     1       qmgr
tlsmgr    unix  -       -       n       1000?   1       tlsmgr
rewrite   unix  -       -       n       -       -       trivial-rewrite
bounce    unix  -       -       n       -       0       bounce
defer     unix  -       -       n       -       0       bounce
trace     unix  -       -       n       -       0       bounce
verify    unix  -       -       n       -       1       verify
flush     unix  n       -       n       1000?   0       flush
proxymap  unix  -       -       n       -       -       proxymap
proxywrite unix -       -       n       -       1       proxymap
showq     unix  n       -       n       -       -       showq
error     unix  -       -       n       -       -       error
retry     unix  -       -       n       -       -       error
discard   unix  -       -       n       -       -       discard
local     unix  -       n       n       -       -       local
virtual   unix  -       n       n       -       -       virtual
lmtp      unix  -       -       n       -       -       lmtp
anvil     unix  -       -       n       -       1       anvil
scache    unix  -       -       n       -       1       scache

# Pixel filter service
pixelfilter unix -   -   n   -   10  pipe
  flags=Xhq user=nobody argv=/usr/local/bin/mailserver filter
"#;

const DEFAULT_DOVECOT_CONF: &str = r#"# Generated by mailserver
protocols = imap pop3 lmtp
hostname = {{ hostname }}

mail_location = maildir:/data/mail/%d/%n/Maildir

ssl = required
ssl_cert = </data/ssl/cert.pem
ssl_key = </data/ssl/key.pem

passdb {
  driver = passwd-file
  args = /etc/dovecot/passwd
}

userdb {
  driver = static
  args = uid=vmail gid=vmail home=/data/mail/%d/%n
}

auth_username_format = %u

service auth {
  inet_listener sasl {
    port = 12345
  }
}

service lmtp {
  inet_listener lmtp {
    port = 24
  }
}

service imap-login {
  inet_listener imap {
    port = 143
  }
  inet_listener imaps {
    port = 993
    ssl = yes
  }
}

service pop3-login {
  inet_listener pop3 {
    port = 110
  }
  inet_listener pop3s {
    port = 995
    ssl = yes
  }
}

namespace inbox {
  inbox = yes

  mailbox Sent {
    auto = subscribe
    special_use = \Sent
  }

  mailbox Drafts {
    auto = subscribe
    special_use = \Drafts
  }

  mailbox Trash {
    auto = subscribe
    special_use = \Trash
  }

  mailbox Junk {
    auto = subscribe
    special_use = \Junk
  }
}
"#;

const DEFAULT_OPENDKIM_CONF: &str = r#"# Generated by mailserver
Syslog          yes
SyslogSuccess   yes
LogWhy          yes
Mode            sv
Canonicalization relaxed/simple
KeyTable        /etc/opendkim/KeyTable
SigningTable     refile:/etc/opendkim/SigningTable
ExternalIgnoreList /etc/opendkim/TrustedHosts
InternalHosts   /etc/opendkim/TrustedHosts
Socket          inet:8891@localhost
PidFile         /run/opendkim/opendkim.pid
UserID          opendkim
UMask           007
"#;

fn safe_filename(name: &str) -> String {
    name.chars()
        .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-')
        .collect()
}

pub fn generate_all_configs(db: &Database, hostname: &str) {
    info!(
        "[config] generating all configuration files for hostname={}",
        hostname
    );
    generate_postfix_main_cf(hostname);
    generate_postfix_master_cf();
    generate_virtual_domains(db);
    generate_virtual_mailboxes(db);
    generate_virtual_aliases(db);
    generate_sender_login_maps(db);
    generate_dovecot_conf(hostname);
    generate_dovecot_passwd(db);
    generate_opendkim_conf();
    generate_opendkim_tables(db);
    postmap_files();
    reload_services();
    info!("[config] all configuration files generated successfully");
}

pub fn generate_postfix_main_cf(hostname: &str) {
    info!(
        "[config] generating /etc/postfix/main.cf for hostname={}",
        hostname
    );
    let mydomain = hostname.splitn(2, '.').nth(1).unwrap_or(hostname);

    let template = load_template("postfix-main.cf.txt").unwrap_or_else(|_| {
        warn!("[config] postfix-main.cf.txt template not found, using fallback");
        DEFAULT_POSTFIX_MAIN_CF.to_string()
    });

    let config = template
        .replace("{{ hostname }}", hostname)
        .replace("{{ mydomain }}", mydomain);

    match fs::write("/etc/postfix/main.cf", config) {
        Ok(_) => debug!("[config] wrote /etc/postfix/main.cf"),
        Err(e) => error!("[config] failed to write /etc/postfix/main.cf: {}", e),
    }
}

pub fn generate_postfix_master_cf() {
    info!("[config] generating /etc/postfix/master.cf");
    let config = load_template("postfix-master.cf.txt").unwrap_or_else(|_| {
        warn!("[config] postfix-master.cf.txt template not found, using fallback");
        DEFAULT_POSTFIX_MASTER_CF.to_string()
    });

    match fs::write("/etc/postfix/master.cf", config) {
        Ok(_) => debug!("[config] wrote /etc/postfix/master.cf"),
        Err(e) => error!("[config] failed to write /etc/postfix/master.cf: {}", e),
    }
}

pub fn generate_virtual_domains(db: &Database) {
    info!("[config] generating /etc/postfix/virtual_domains");
    let domains = db.list_domains();
    let mut lines = String::from("# Generated by mailserver\n");
    for d in &domains {
        if d.active {
            lines.push_str(&format!("{} OK\n", d.domain));
        }
    }
    match fs::write("/etc/postfix/virtual_domains", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/virtual_domains ({} domains)",
            domains.len()
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/virtual_domains: {}",
            e
        ),
    }
}

pub fn generate_virtual_mailboxes(db: &Database) {
    info!("[config] generating /etc/postfix/vmailbox");
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = String::from("# Generated by mailserver\n");
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{} {}/{}/Maildir/\n",
                a.username, domain, domain, a.username
            ));
        }
    }
    match fs::write("/etc/postfix/vmailbox", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/vmailbox ({} accounts)",
            accounts.len()
        ),
        Err(e) => error!("[config] failed to write /etc/postfix/vmailbox: {}", e),
    }
}

pub fn generate_virtual_aliases(db: &Database) {
    info!("[config] generating /etc/postfix/virtual_aliases");
    let aliases = db.list_all_aliases_with_domain();
    let mut lines = String::from("# Generated by mailserver\n");
    for a in &aliases {
        if a.active {
            lines.push_str(&format!("{} {}\n", a.source, a.destination));
        }
    }
    match fs::write("/etc/postfix/virtual_aliases", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/virtual_aliases ({} aliases)",
            aliases.len()
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/virtual_aliases: {}",
            e
        ),
    }
}

pub fn generate_sender_login_maps(db: &Database) {
    info!("[config] generating /etc/postfix/sender_login_maps");
    let entries = db.get_sender_login_map();

    // Group by alias source: each alias source maps to all account emails on the same domain
    let mut map: std::collections::HashMap<String, Vec<String>> = std::collections::HashMap::new();
    for (alias_source, account_email) in &entries {
        map.entry(alias_source.clone())
            .or_default()
            .push(account_email.clone());
    }

    // Also allow each account to send as itself
    let accounts = db.list_all_accounts_with_domain();
    for a in &accounts {
        if a.active {
            if let Some(ref domain) = a.domain_name {
                let email = format!("{}@{}", a.username, domain);
                map.entry(email.clone()).or_default().push(email);
            }
        }
    }

    let mut lines = String::from("# Generated by mailserver\n");
    for (sender, logins) in &map {
        // Deduplicate logins
        let mut unique: Vec<&String> = logins.iter().collect();
        unique.sort();
        unique.dedup();
        lines.push_str(&format!(
            "{} {}\n",
            sender,
            unique
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<_>>()
                .join(",")
        ));
    }
    match fs::write("/etc/postfix/sender_login_maps", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/sender_login_maps ({} entries)",
            map.len()
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/sender_login_maps: {}",
            e
        ),
    }
}

pub fn generate_dovecot_conf(hostname: &str) {
    info!(
        "[config] generating /etc/dovecot/dovecot.conf for hostname={}",
        hostname
    );
    let template = load_template("dovecot.conf.txt").unwrap_or_else(|_| {
        warn!("[config] dovecot.conf.txt template not found, using fallback");
        DEFAULT_DOVECOT_CONF.to_string()
    });

    let config = template.replace("{{ hostname }}", hostname);

    match fs::write("/etc/dovecot/dovecot.conf", config) {
        Ok(_) => debug!("[config] wrote /etc/dovecot/dovecot.conf"),
        Err(e) => error!("[config] failed to write /etc/dovecot/dovecot.conf: {}", e),
    }
}

pub fn generate_dovecot_passwd(db: &Database) {
    info!("[config] generating /etc/dovecot/passwd");
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = String::new();
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{}:{{BLF-CRYPT}}{}:::::\n",
                a.username, domain, a.password_hash
            ));
        }
    }
    match fs::write("/etc/dovecot/passwd", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/dovecot/passwd ({} accounts)",
            accounts.len()
        ),
        Err(e) => error!("[config] failed to write /etc/dovecot/passwd: {}", e),
    }
}

pub fn generate_opendkim_conf() {
    info!("[config] generating /etc/opendkim/opendkim.conf");
    let config = load_template("opendkim.conf.txt").unwrap_or_else(|_| {
        warn!("[config] opendkim.conf.txt template not found, using fallback");
        DEFAULT_OPENDKIM_CONF.to_string()
    });

    match fs::write("/etc/opendkim/opendkim.conf", config) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/opendkim.conf"),
        Err(e) => error!(
            "[config] failed to write /etc/opendkim/opendkim.conf: {}",
            e
        ),
    }
}

pub fn generate_opendkim_tables(db: &Database) {
    info!("[config] generating OpenDKIM key/signing/trusted tables");
    let domains = db.list_domains();

    let mut key_table = String::from("# Generated by mailserver\n");
    let mut signing_table = String::from("# Generated by mailserver\n");
    let mut trusted_hosts = String::from("# Generated by mailserver\n127.0.0.1\nlocalhost\n");
    let mut dkim_count: usize = 0;

    for d in &domains {
        if !d.active {
            debug!("[config] skipping inactive domain {} for DKIM", d.domain);
            continue;
        }
        if let Some(ref private_key) = d.dkim_private_key {
            let selector = &d.dkim_selector;
            let domain = &d.domain;
            let key_path = format!("/data/dkim/{}.private", safe_filename(domain));

            // Write the private key file
            if let Err(e) = fs::create_dir_all("/data/dkim") {
                error!("[config] failed to create /data/dkim directory: {}", e);
            }
            match fs::write(&key_path, private_key) {
                Ok(_) => debug!(
                    "[config] wrote DKIM private key for domain={} to {}",
                    domain, key_path
                ),
                Err(e) => error!(
                    "[config] failed to write DKIM private key for domain={}: {}",
                    domain, e
                ),
            }

            key_table.push_str(&format!(
                "{}._domainkey.{} {}:{}:{}\n",
                selector, domain, domain, selector, key_path
            ));
            signing_table.push_str(&format!(
                "*@{} {}._domainkey.{}\n",
                domain, selector, domain
            ));
            trusted_hosts.push_str(&format!("{}\n", domain));
            dkim_count += 1;
        } else {
            debug!("[config] domain {} has no DKIM key configured", d.domain);
        }
    }

    info!(
        "[config] writing OpenDKIM tables ({} DKIM-enabled domains)",
        dkim_count
    );
    match fs::write("/etc/opendkim/KeyTable", key_table) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/KeyTable"),
        Err(e) => error!("[config] failed to write /etc/opendkim/KeyTable: {}", e),
    }
    match fs::write("/etc/opendkim/SigningTable", signing_table) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/SigningTable"),
        Err(e) => error!("[config] failed to write /etc/opendkim/SigningTable: {}", e),
    }
    match fs::write("/etc/opendkim/TrustedHosts", trusted_hosts) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/TrustedHosts"),
        Err(e) => error!("[config] failed to write /etc/opendkim/TrustedHosts: {}", e),
    }
}

pub fn postmap_files() {
    info!("[config] running postmap on virtual maps");
    for path in &[
        "/etc/postfix/virtual_domains",
        "/etc/postfix/vmailbox",
        "/etc/postfix/virtual_aliases",
        "/etc/postfix/sender_login_maps",
    ] {
        // Explicitly specify lmdb format for Alpine Linux compatibility
        let lmdb_path = format!("lmdb:{}", path);
        match Command::new("postmap").arg(&lmdb_path).output() {
            Ok(output) if output.status.success() => {
                debug!("[config] postmap succeeded for {}", lmdb_path);
            }
            Ok(output) => {
                warn!(
                    "[config] postmap for {} exited with status {}: {}",
                    lmdb_path,
                    output.status,
                    String::from_utf8_lossy(&output.stderr)
                );
            }
            Err(e) => {
                warn!("[config] failed to run postmap for {}: {}", lmdb_path, e);
            }
        }
    }
}

pub fn reload_services() {
    info!("[config] reloading mail services");

    match Command::new("postfix").arg("reload").output() {
        Ok(output) if output.status.success() => info!("[config] postfix reloaded successfully"),
        Ok(output) => warn!(
            "[config] postfix reload exited with status {}: {}",
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ),
        Err(e) => warn!("[config] failed to reload postfix: {}", e),
    }

    match Command::new("dovecot").arg("reload").output() {
        Ok(output) if output.status.success() => info!("[config] dovecot reloaded successfully"),
        Ok(output) => warn!(
            "[config] dovecot reload exited with status {}: {}",
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ),
        Err(e) => warn!("[config] failed to reload dovecot: {}", e),
    }

    // Signal opendkim to reload via USR1
    match Command::new("pgrep").arg("opendkim").output() {
        Ok(output) => {
            let pids = String::from_utf8_lossy(&output.stdout);
            for pid in pids.split_whitespace() {
                match Command::new("kill").args(["-USR1", pid]).output() {
                    Ok(_) => debug!("[config] sent USR1 to opendkim pid={}", pid),
                    Err(e) => warn!("[config] failed to signal opendkim pid={}: {}", pid, e),
                }
            }
            if pids.trim().is_empty() {
                debug!("[config] no opendkim process found to signal");
            }
        }
        Err(e) => warn!("[config] failed to find opendkim process: {}", e),
    }

    info!("[config] service reload complete");
}
