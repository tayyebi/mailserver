use crate::db::Database;
use chrono::Utc;
use log::{debug, error, info, warn};
use std::fs;
use std::io::Write;
use std::path::Path;
use std::process::Command;

#[cfg(unix)]
use std::os::unix::fs::OpenOptionsExt;

// ── Template Loading ──

fn load_template(filename: &str) -> std::io::Result<String> {
    // Try to load from templates/config directory
    let paths = vec![
        format!("templates/config/{}", filename),
        format!("/app/templates/config/{}", filename),
    ];

    for path in paths {
        if Path::new(&path).exists() {
            debug!("[config] loading template from {}", path);
            return fs::read_to_string(path);
        }
    }

    Err(std::io::Error::new(
        std::io::ErrorKind::NotFound,
        format!("Template {} not found in any template directory", filename),
    ))
}

fn safe_filename(name: &str) -> String {
    name.chars()
        .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-')
        .collect()
}

fn generated_header() -> String {
    generated_header_with(&generated_at())
}

fn generated_header_with(timestamp: &str) -> String {
    format!("# Generated by mailserver on {}\n", timestamp)
}

fn generated_at() -> String {
    Utc::now().to_rfc3339()
}

/// Write content to a file with secure permissions (0600 - owner read/write only)
/// This is used for sensitive files like DKIM private keys and password databases
/// 
/// Defense in depth approach:
/// 1. mode(0o600) sets permissions on newly created files
/// 2. set_permissions() ensures correct permissions even if file already existed
/// 3. truncate(true) clears existing content before writing
/// 4. sync_all() ensures data is flushed to disk
#[cfg(unix)]
fn write_secure_file(path: &str, content: &str) -> std::io::Result<()> {
    use std::fs::{OpenOptions, Permissions};
    use std::os::unix::fs::PermissionsExt;
    
    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .mode(0o600)  // Sets permissions for newly created files
        .open(path)?;
    
    file.write_all(content.as_bytes())?;
    
    // Ensure data is flushed to disk
    file.sync_all()?;
    
    // Explicitly set permissions to ensure they're correct even if file existed
    // This is necessary because .mode() only affects newly created files
    let permissions = Permissions::from_mode(0o600);
    std::fs::set_permissions(path, permissions)?;
    
    Ok(())
}

/// Fallback for non-Unix systems (Windows, etc.)
/// WARNING: This does not enforce secure file permissions
#[cfg(not(unix))]
fn write_secure_file(path: &str, content: &str) -> std::io::Result<()> {
    warn!(
        "[config] Writing {} without secure permissions - platform does not support Unix file modes",
        path
    );
    fs::write(path, content)
}

#[cfg(unix)]
fn set_dovecot_passwd_permissions(path: &str) -> std::io::Result<()> {
    use std::fs::Permissions;
    use std::os::unix::fs::PermissionsExt;
    
    std::fs::set_permissions(path, Permissions::from_mode(0o640))?;
    let output = Command::new("chown").args(["root:dovecot", path]).output()?;
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(std::io::Error::other(format!(
            "chown root:dovecot {} failed with status {}: {}",
            path, output.status, stderr
        )));
    }
    
    Ok(())
}

pub fn generate_all_configs(db: &Database, hostname: &str) {
    info!(
        "[config] generating all configuration files for hostname={}",
        hostname
    );
    generate_postfix_main_cf(db, hostname);
    generate_postfix_master_cf(db);
    generate_virtual_domains(db);
    generate_virtual_mailboxes(db);
    generate_virtual_aliases(db);
    generate_recipient_bcc_maps(db);
    generate_sender_login_maps(db);
    generate_dovecot_conf(hostname);
    generate_dovecot_passwd(db);
    generate_opendkim_conf();
    generate_opendkim_tables(db);
    postmap_files();
    reload_services();
    info!("[config] all configuration files generated successfully");
}

pub fn generate_postfix_main_cf(db: &Database, hostname: &str) {
    info!(
        "[config] generating /etc/postfix/main.cf for hostname={}",
        hostname
    );
    let mydomain = hostname.splitn(2, '.').nth(1).unwrap_or(hostname);

    let template = load_template("postfix-main.cf.txt").expect("postfix-main.cf.txt template not found");
    let generated_at = generated_at();

    let milter_enabled = db
        .get_setting("feature_milter_enabled")
        .map(|v| v != "false")
        .unwrap_or(true);

    let milter_config = if milter_enabled {
        "smtpd_milters = inet:127.0.0.1:8891\nnon_smtpd_milters = inet:127.0.0.1:8891\nmilter_default_action = accept".to_string()
    } else {
        "# milter disabled via feature settings".to_string()
    };

    let rbl_hostnames = db.list_enabled_spambl_hostnames();
    // Trailing ", " is intentional: the placeholder sits before reject_unauth_destination
    // in the template, so each rbl check must be followed by a comma separator.
    let rbl_checks = if rbl_hostnames.is_empty() {
        String::new()
    } else {
        rbl_hostnames
            .iter()
            .map(|h| format!("warn_if_reject reject_rbl_client {}", h))
            .collect::<Vec<_>>()
            .join(", ")
            + ", "
    };

    let config = template
        .replace("{{ generated_at }}", &generated_at)
        .replace("{{ hostname }}", hostname)
        .replace("{{ mydomain }}", mydomain)
        .replace("{{ milter_config }}", &milter_config)
        .replace("{{ rbl_checks }}", &rbl_checks);

    match fs::write("/etc/postfix/main.cf", config) {
        Ok(_) => debug!("[config] wrote /etc/postfix/main.cf"),
        Err(e) => error!("[config] failed to write /etc/postfix/main.cf: {}", e),
    }
}

pub fn generate_postfix_master_cf(db: &Database) {
    info!("[config] generating /etc/postfix/master.cf");
    let template = load_template("postfix-master.cf.txt").expect("postfix-master.cf.txt template not found");

    let filter_enabled = db
        .get_setting("feature_filter_enabled")
        .map(|v| v != "false")
        .unwrap_or(true);

    let filter_line = if filter_enabled {
        "  -o content_filter=pixelfilter:local\n"
    } else {
        ""
    };

    let filter_service = if filter_enabled {
        "# Pixel filter service\npixelfilter unix -   y   n   -   10  pipe\n  flags=hq user=postfix argv=/usr/local/bin/mailserver filter -f ${sender} -- ${recipient}\n"
    } else {
        "# Pixel filter service disabled via feature settings\n"
    };

    let config = template
        .replace("{{ generated_at }}", &generated_at())
        .replace("{{ filter_submission }}", filter_line)
        .replace("{{ filter_smtps }}", filter_line)
        .replace("{{ filter_service }}", filter_service);

    match fs::write("/etc/postfix/master.cf", config) {
        Ok(_) => debug!("[config] wrote /etc/postfix/master.cf"),
        Err(e) => error!("[config] failed to write /etc/postfix/master.cf: {}", e),
    }
}

pub fn generate_virtual_domains(db: &Database) {
    info!("[config] generating /etc/postfix/virtual_domains");
    let domains = db.list_domains();
    let mut lines = generated_header();
    for d in &domains {
        if d.active {
            lines.push_str(&format!("{} OK\n", d.domain));
        }
    }
    match fs::write("/etc/postfix/virtual_domains", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/virtual_domains ({} domains)",
            domains.len()
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/virtual_domains: {}",
            e
        ),
    }
}

pub fn generate_virtual_mailboxes(db: &Database) {
    info!("[config] generating /etc/postfix/vmailbox");
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = generated_header();
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{} {}/{}/Maildir/\n",
                a.username, domain, domain, a.username
            ));
        }
    }
    match fs::write("/etc/postfix/vmailbox", lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/vmailbox ({} accounts)",
            accounts.len()
        ),
        Err(e) => error!("[config] failed to write /etc/postfix/vmailbox: {}", e),
    }
}

/// Build the ordered list of (source, destination) pairs for the virtual_aliases file.
///
/// Rules:
/// 1. Catch-all entries (`@domain`) are placed **before** specific entries (`user@domain`).
///    In LMDB the last-written value for a key wins, so specific entries — written last —
///    always override any same-key catch-all.
/// 2. For every account whose domain has a catch-all alias/forwarding but that does **not**
///    already have an explicit alias or forwarding, an identity entry
///    (`user@domain → user@domain`) is injected.  This prevents Postfix from falling
///    through to the catch-all for real mailboxes (Postfix checks `virtual_alias_maps`
///    before `virtual_mailbox_maps`; without the identity entry the catch-all matches
///    first and mail is silently mis-routed).
fn build_virtual_alias_entries(
    aliases: &[crate::db::Alias],
    forwardings: &[crate::db::Forwarding],
    accounts: &[crate::db::Account],
) -> Vec<(String, String)> {
    let mut catch_all_entries: Vec<(String, String)> = Vec::new();
    let mut specific_entries: Vec<(String, String)> = Vec::new();
    let mut specific_sources: std::collections::HashSet<String> =
        std::collections::HashSet::new();

    for a in aliases {
        if a.active {
            let source = normalize_virtual_alias_source(&a.source, a.domain_name.as_deref());
            if source.starts_with('@') {
                catch_all_entries.push((source, a.destination.clone()));
            } else {
                specific_sources.insert(source.clone());
                specific_entries.push((source, a.destination.clone()));
            }
        }
    }

    // Forwardings: keep_copy entries are handled via recipient_bcc_maps so that local
    // mailbox delivery is not bypassed by the alias map (Postfix drops self-referential
    // alias destinations as loops in virtual-mailbox domains).
    for f in forwardings {
        if f.active {
            if f.keep_copy && !f.source.starts_with('@') {
                // Skip: local delivery uses virtual_mailbox_maps; the external copy is
                // handled by recipient_bcc_maps.  Omitting from specific_sources lets
                // the accounts loop add an identity entry for catch-all protection.
                continue;
            }
            if f.source.starts_with('@') {
                catch_all_entries.push((f.source.clone(), f.destination.clone()));
            } else {
                specific_sources.insert(f.source.clone());
                specific_entries.push((f.source.clone(), f.destination.clone()));
            }
        }
    }

    // Collect the domains that have at least one catch-all entry.
    // For each account in those domains that lacks a specific alias or forwarding,
    // add an identity entry (user@domain → user@domain).  This stops Postfix from
    // falling through to the catch-all when the real mailbox has no explicit alias,
    // which would otherwise silently redirect mail to the catch-all destination.
    let catch_all_domains: std::collections::HashSet<String> = catch_all_entries
        .iter()
        .filter_map(|(source, _)| source.strip_prefix('@').map(str::to_string))
        .collect();

    for a in accounts {
        if a.active {
            if let Some(ref domain) = a.domain_name {
                if catch_all_domains.contains(domain) {
                    let email = format!("{}@{}", a.username, domain);
                    if !specific_sources.contains(&email) {
                        specific_entries.push((email.clone(), email));
                    }
                }
            }
        }
    }

    // Catch-all entries first, then specific entries (explicit aliases last so they win).
    let mut result = catch_all_entries;
    result.extend(specific_entries);
    result
}

pub fn generate_virtual_aliases(db: &Database) {
    info!("[config] generating /etc/postfix/virtual_aliases");
    let aliases = db.list_all_aliases_with_domain();
    let forwardings = db.list_all_forwardings_with_domain();
    let accounts = db.list_all_accounts_with_domain();

    let entries = build_virtual_alias_entries(&aliases, &forwardings, &accounts);
    let active_count = entries.len();
    let mut lines = generated_header();

    for (source, destination) in &entries {
        lines.push_str(&format!("{} {}\n", source, destination));
    }

    // Add a comment if there are no active aliases or forwardings to make the file more informative
    if active_count == 0 {
        lines.push_str("# No active aliases or forwardings configured\n");
        lines.push_str("# Add aliases or forwarding rules in the admin dashboard\n");
    }

    match write_secure_file("/etc/postfix/virtual_aliases", &lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/virtual_aliases with secure permissions ({} active entries)",
            active_count
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/virtual_aliases: {}",
            e
        ),
    }
}

/// Build (source → destination) pairs for the recipient_bcc_maps file.
/// Each active keep_copy=true forwarding (non-catch-all) contributes one entry.
/// Multiple destinations for the same source are comma-joined into one BCC value.
fn build_recipient_bcc_entries(forwardings: &[crate::db::Forwarding]) -> Vec<(String, String)> {
    let mut bcc_map: std::collections::BTreeMap<String, Vec<String>> =
        std::collections::BTreeMap::new();
    for f in forwardings {
        if f.active && f.keep_copy && !f.source.starts_with('@') {
            bcc_map
                .entry(f.source.clone())
                .or_default()
                .push(f.destination.clone());
        }
    }
    bcc_map
        .into_iter()
        .map(|(source, dests)| (source, dests.join(", ")))
        .collect()
}

pub fn generate_recipient_bcc_maps(db: &Database) {
    info!("[config] generating /etc/postfix/recipient_bcc");
    let forwardings = db.list_all_forwardings_with_domain();
    let entries = build_recipient_bcc_entries(&forwardings);
    let mut lines = generated_header();
    for (source, bcc) in &entries {
        lines.push_str(&format!("{} {}\n", source, bcc));
    }
    match write_secure_file("/etc/postfix/recipient_bcc", &lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/recipient_bcc with secure permissions ({} entries)",
            entries.len()
        ),
        Err(e) => error!("[config] failed to write /etc/postfix/recipient_bcc: {}", e),
    }
}

fn normalize_virtual_alias_source(source: &str, domain: Option<&str>) -> String {
    let trimmed = source.trim();
    if let Some(rest) = trimmed.strip_prefix("*@") {
        return format!("@{}", rest);
    }
    if trimmed == "*" {
        if let Some(domain) = domain {
            return format!("@{}", domain);
        } else {
            warn!("[config] alias source '*' has no domain context; keeping source as-is");
            return trimmed.to_string();
        }
    }
    trimmed.to_string()
}

pub fn generate_sender_login_maps(db: &Database) {
    info!("[config] generating /etc/postfix/sender_login_maps");
    let entries = db.get_sender_login_map();

    // Group by alias source: normalize wildcards (*@domain → @domain) so Postfix
    // can use them for wildcard lookups in smtpd_sender_login_maps.
    let mut map: std::collections::HashMap<String, Vec<String>> = std::collections::HashMap::new();
    for (alias_source, account_email) in &entries {
        let normalized_source = normalize_virtual_alias_source(alias_source, None);
        map.entry(normalized_source)
            .or_default()
            .push(account_email.clone());
    }

    // Also allow each account to send as itself
    let accounts = db.list_all_accounts_with_domain();
    for a in &accounts {
        if a.active {
            if let Some(ref domain) = a.domain_name {
                let email = format!("{}@{}", a.username, domain);
                map.entry(email.clone()).or_default().push(email);
            }
        }
    }

    let mut lines = generated_header();
    for (sender, logins) in &map {
        // Deduplicate logins
        let mut unique: Vec<&String> = logins.iter().collect();
        unique.sort();
        unique.dedup();
        lines.push_str(&format!(
            "{} {}\n",
            sender,
            unique
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<_>>()
                .join(",")
        ));
    }
    match write_secure_file("/etc/postfix/sender_login_maps", &lines) {
        Ok(_) => debug!(
            "[config] wrote /etc/postfix/sender_login_maps with secure permissions ({} entries)",
            map.len()
        ),
        Err(e) => error!(
            "[config] failed to write /etc/postfix/sender_login_maps: {}",
            e
        ),
    }
}

pub fn generate_dovecot_conf(hostname: &str) {
    info!(
        "[config] generating /etc/dovecot/dovecot.conf for hostname={}",
        hostname
    );
    let template = load_template("dovecot.conf.txt").expect("dovecot.conf.txt template not found");

    let config = template
        .replace("{{ generated_at }}", &generated_at())
        .replace("{{ hostname }}", hostname);

    match fs::write("/etc/dovecot/dovecot.conf", config) {
        Ok(_) => debug!("[config] wrote /etc/dovecot/dovecot.conf"),
        Err(e) => error!("[config] failed to write /etc/dovecot/dovecot.conf: {}", e),
    }
}

pub fn generate_dovecot_passwd(db: &Database) {
    let passwd_path = "/etc/dovecot/passwd";
    info!("[config] generating {}", passwd_path);
    let accounts = db.list_all_accounts_with_domain();
    let mut lines = String::new();
    for a in &accounts {
        if !a.active {
            continue;
        }
        if let Some(ref domain) = a.domain_name {
            lines.push_str(&format!(
                "{}@{}:{{BLF-CRYPT}}{}:::::\n",
                a.username, domain, a.password_hash
            ));
        }
    }
    match write_secure_file(passwd_path, &lines) {
        Ok(_) => {
            #[cfg(unix)]
            if let Err(e) = set_dovecot_passwd_permissions(passwd_path) {
                use std::fs::Permissions;
                use std::os::unix::fs::PermissionsExt;

                warn!(
                    "[config] failed to set /etc/dovecot/passwd ownership/permissions ({}), falling back to mode 0644",
                    e
                );
                if let Err(e2) = std::fs::set_permissions(passwd_path, Permissions::from_mode(0o644)) {
                    error!("[config] failed to apply fallback permissions for /etc/dovecot/passwd: {}", e2);
                    return;
                }
            }
            debug!(
                "[config] wrote /etc/dovecot/passwd with secure permissions ({} accounts)",
                accounts.len()
            )
        }
        Err(e) => error!("[config] failed to write /etc/dovecot/passwd: {}", e),
    }
}

pub fn generate_opendkim_conf() {
    info!("[config] generating /etc/opendkim/opendkim.conf");
    let template = load_template("opendkim.conf.txt").expect("opendkim.conf.txt template not found");
    let config = template.replace("{{ generated_at }}", &generated_at());

    match fs::write("/etc/opendkim/opendkim.conf", config) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/opendkim.conf"),
        Err(e) => error!(
            "[config] failed to write /etc/opendkim/opendkim.conf: {}",
            e
        ),
    }
}

pub fn generate_opendkim_tables(db: &Database) {
    info!("[config] generating OpenDKIM key/signing/trusted tables");
    let domains = db.list_domains();

    let timestamp = generated_at();
    let header = generated_header_with(&timestamp);
    let mut key_table = header.clone();
    let mut signing_table = header.clone();
    let mut trusted_hosts = format!("{}127.0.0.1\nlocalhost\n", header);
    let mut dkim_count: usize = 0;

    for d in &domains {
        if !d.active {
            debug!("[config] skipping inactive domain {} for DKIM", d.domain);
            continue;
        }
        if let Some(ref private_key) = d.dkim_private_key {
            let selector = &d.dkim_selector;
            let domain = &d.domain;
            let key_path = format!("/data/dkim/{}.private", safe_filename(domain));

            // Write the private key file with secure permissions (0600)
            if let Err(e) = fs::create_dir_all("/data/dkim") {
                error!("[config] failed to create /data/dkim directory: {}", e);
            }
            match write_secure_file(&key_path, private_key) {
                Ok(_) => {
                    debug!(
                        "[config] wrote DKIM private key for domain={} to {} with secure permissions",
                        domain, key_path
                    );
                    // Ensure opendkim (which drops privileges to the opendkim user via UserID in
                    // opendkim.conf) can read the private key file.
                    match Command::new("chown").args(["opendkim:opendkim", &key_path]).output() {
                        Ok(o) if o.status.success() => debug!(
                            "[config] set opendkim ownership on {}",
                            key_path
                        ),
                        Ok(o) => warn!(
                            "[config] chown opendkim:opendkim {} failed: {}",
                            key_path,
                            String::from_utf8_lossy(&o.stderr)
                        ),
                        Err(e) => warn!("[config] failed to chown {}: {}", key_path, e),
                    }
                }
                Err(e) => error!(
                    "[config] failed to write DKIM private key for domain={}: {}",
                    domain, e
                ),
            }

            key_table.push_str(&format!(
                "{}._domainkey.{} {}:{}:{}\n",
                selector, domain, domain, selector, key_path
            ));
            signing_table.push_str(&format!(
                "*@{} {}._domainkey.{}\n",
                domain, selector, domain
            ));
            trusted_hosts.push_str(&format!("{}\n", domain));
            dkim_count += 1;
        } else {
            debug!("[config] domain {} has no DKIM key configured", d.domain);
        }
    }

    info!(
        "[config] writing OpenDKIM tables ({} DKIM-enabled domains)",
        dkim_count
    );
    match fs::write("/etc/opendkim/KeyTable", key_table) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/KeyTable"),
        Err(e) => error!("[config] failed to write /etc/opendkim/KeyTable: {}", e),
    }
    match fs::write("/etc/opendkim/SigningTable", signing_table) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/SigningTable"),
        Err(e) => error!("[config] failed to write /etc/opendkim/SigningTable: {}", e),
    }
    match fs::write("/etc/opendkim/TrustedHosts", trusted_hosts) {
        Ok(_) => debug!("[config] wrote /etc/opendkim/TrustedHosts"),
        Err(e) => error!("[config] failed to write /etc/opendkim/TrustedHosts: {}", e),
    }
}

pub fn postmap_files() {
    info!("[config] running postmap on virtual maps");
    for path in &[
        "/etc/postfix/virtual_domains",
        "/etc/postfix/vmailbox",
        "/etc/postfix/virtual_aliases",
        "/etc/postfix/recipient_bcc",
        "/etc/postfix/sender_login_maps",
    ] {
        // Explicitly specify lmdb format for Alpine Linux compatibility
        let lmdb_path = format!("lmdb:{}", path);
        match Command::new("postmap").arg(&lmdb_path).output() {
            Ok(output) if output.status.success() => {
                debug!("[config] postmap succeeded for {}", lmdb_path);
            }
            Ok(output) => {
                warn!(
                    "[config] postmap for {} exited with status {}: {}",
                    lmdb_path,
                    output.status,
                    String::from_utf8_lossy(&output.stderr)
                );
            }
            Err(e) => {
                warn!("[config] failed to run postmap for {}: {}", lmdb_path, e);
            }
        }
    }
}

pub fn reload_services() {
    info!("[config] reloading mail services");

    match Command::new("postfix").arg("reload").output() {
        Ok(output) if output.status.success() => info!("[config] postfix reloaded successfully"),
        Ok(output) => warn!(
            "[config] postfix reload exited with status {}: {}",
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ),
        Err(e) => warn!("[config] failed to reload postfix: {}", e),
    }

    match Command::new("dovecot").arg("reload").output() {
        Ok(output) if output.status.success() => info!("[config] dovecot reloaded successfully"),
        Ok(output) => warn!(
            "[config] dovecot reload exited with status {}: {}",
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ),
        Err(e) => warn!("[config] failed to reload dovecot: {}", e),
    }

    // Signal opendkim to reload via USR1
    match Command::new("pgrep").arg("opendkim").output() {
        Ok(output) => {
            let pids = String::from_utf8_lossy(&output.stdout);
            for pid in pids.split_whitespace() {
                match Command::new("kill").args(["-USR1", pid]).output() {
                    Ok(_) => debug!("[config] sent USR1 to opendkim pid={}", pid),
                    Err(e) => warn!("[config] failed to signal opendkim pid={}: {}", pid, e),
                }
            }
            if pids.trim().is_empty() {
                debug!("[config] no opendkim process found to signal");
            }
        }
        Err(e) => warn!("[config] failed to find opendkim process: {}", e),
    }

    info!("[config] service reload complete");
}

pub fn restart_services() -> Result<String, String> {
    info!("[config] restarting all mail services via supervisorctl");

    let programs = ["postfix", "dovecot", "opendkim"];
    let mut results = Vec::new();

    for program in &programs {
        match Command::new("supervisorctl")
            .args(["restart", program])
            .output()
        {
            Ok(output) if output.status.success() => {
                info!("[config] {} restarted successfully", program);
                results.push(format!("{}: restarted", program));
            }
            Ok(output) => {
                let stderr = String::from_utf8_lossy(&output.stderr);
                warn!(
                    "[config] supervisorctl restart {} exited with status {}: {}",
                    program, output.status, stderr
                );
                results.push(format!("{}: failed ({})", program, stderr.trim()));
            }
            Err(e) => {
                warn!("[config] failed to restart {}: {}", program, e);
                results.push(format!("{}: error ({})", program, e));
            }
        }
    }

    info!("[config] service restart complete");
    Ok(results.join("; "))
}

pub fn restart_container() -> Result<(), String> {
    info!("[config] restarting Docker container via socket");

    let socket_path = "/var/run/docker.sock";
    if !Path::new(socket_path).exists() {
        error!("[config] Docker socket not found at {}", socket_path);
        return Err("Docker socket not found. Ensure /var/run/docker.sock is mounted into the container.".to_string());
    }

    // Read our own container ID from /proc/self/mountinfo or hostname
    let container_id = read_container_id().ok_or_else(|| {
        "Could not determine container ID from /proc/self/mountinfo or hostname. This feature requires running in a standard Docker environment.".to_string()
    })?;

    info!("[config] sending restart request for container {}", container_id);

    // Use curl to talk to the Docker socket
    let result = Command::new("curl")
        .args([
            "--unix-socket", socket_path,
            "-X", "POST",
            &format!("http://localhost/containers/{}/restart", container_id),
        ])
        .output();

    match result {
        Ok(output) if output.status.success() => {
            info!("[config] container restart request sent successfully");
            Ok(())
        }
        Ok(output) => {
            let stderr = String::from_utf8_lossy(&output.stderr);
            let stdout = String::from_utf8_lossy(&output.stdout);
            error!(
                "[config] container restart failed: stdout={}, stderr={}",
                stdout, stderr
            );
            Err(format!("Container restart failed: {} {}", stdout, stderr))
        }
        Err(e) => {
            error!("[config] failed to send container restart request: {}", e);
            Err(format!("Failed to send restart request: {}", e))
        }
    }
}

fn read_container_id() -> Option<String> {
    // Try /proc/self/mountinfo (works in most Docker environments)
    if let Ok(content) = fs::read_to_string("/proc/self/mountinfo") {
        for line in content.lines() {
            // Look for docker container ID pattern in mount paths
            if let Some(id) = extract_container_id_from_path(line) {
                debug!("[config] found container ID from mountinfo: {}", id);
                return Some(id);
            }
        }
    }

    // Try hostname as fallback (Docker sets hostname to the short 12-char container ID by default;
    // the Docker API accepts short ID prefixes for container identification)
    if let Ok(hostname) = fs::read_to_string("/etc/hostname") {
        let hostname = hostname.trim().to_string();
        if hostname.len() == 12 && hostname.chars().all(|c| c.is_ascii_hexdigit()) {
            debug!("[config] using hostname as container ID: {}", hostname);
            return Some(hostname);
        }
    }

    // Try HOSTNAME env var
    if let Ok(hostname) = std::env::var("HOSTNAME") {
        let hostname = hostname.trim().to_string();
        if hostname.len() == 12 && hostname.chars().all(|c| c.is_ascii_hexdigit()) {
            debug!("[config] using HOSTNAME env var as container ID: {}", hostname);
            return Some(hostname);
        }
    }

    None
}

fn extract_container_id_from_path(line: &str) -> Option<String> {
    // Look for /docker/<container_id> pattern in mountinfo
    for part in line.split('/') {
        // Container IDs are 64 hex characters
        if part.len() == 64 && part.chars().all(|c| c.is_ascii_hexdigit()) {
            return Some(part.to_string());
        }
    }
    None
}

#[cfg(test)]
mod tests {
    use super::normalize_virtual_alias_source;
    use super::extract_container_id_from_path;
    use super::load_template;

    #[test]
    fn normalize_virtual_alias_source_rewrites_catch_all_patterns() {
        assert_eq!(
            normalize_virtual_alias_source("*@example.com", Some("example.com")),
            "@example.com"
        );
        assert_eq!(
            normalize_virtual_alias_source("*", Some("example.com")),
            "@example.com"
        );
        assert_eq!(
            normalize_virtual_alias_source("info@example.com", Some("example.com")),
            "info@example.com"
        );
        assert_eq!(normalize_virtual_alias_source("*", None), "*");
    }

    #[test]
    fn extract_container_id_from_mountinfo_line() {
        let line = "1234 5678 0:123 / /sys/fs/cgroup rw - cgroup2 /docker/abc123def456abc123def456abc123def456abc123def456abc123def456abcd";
        let result = extract_container_id_from_path(line);
        assert_eq!(
            result,
            Some("abc123def456abc123def456abc123def456abc123def456abc123def456abcd".to_string())
        );
    }

    #[test]
    fn extract_container_id_returns_none_for_no_id() {
        let line = "some random text without container ids";
        assert_eq!(extract_container_id_from_path(line), None);
    }

    #[test]
    fn extract_container_id_ignores_short_hex() {
        let line = "/docker/abc123 something";
        assert_eq!(extract_container_id_from_path(line), None);
    }

    #[test]
    fn master_cf_template_includes_smtp_unix_transport() {
        let template = load_template("postfix-master.cf.txt")
            .expect("postfix-master.cf.txt template should be loadable");
        assert!(
            template.contains("smtp      unix  -       -       n       -       -       smtp"),
            "master.cf template must include the smtp unix transport for outbound mail delivery"
        );
    }

    #[test]
    fn sender_login_maps_normalizes_wildcard_sources() {
        // Postfix smtpd_sender_login_maps uses @domain format for wildcard lookups.
        // Wildcard alias sources stored as *@domain must be normalized to @domain.
        assert_eq!(
            normalize_virtual_alias_source("*@gordarg.com", None),
            "@gordarg.com"
        );
        assert_eq!(
            normalize_virtual_alias_source("*@tyyi.net", None),
            "@tyyi.net"
        );
        // Specific addresses must remain unchanged
        assert_eq!(
            normalize_virtual_alias_source("info@gordarg.com", None),
            "info@gordarg.com"
        );
        assert_eq!(
            normalize_virtual_alias_source("m@tyyi.net", None),
            "m@tyyi.net"
        );
    }

    #[test]
    fn main_cf_template_exports_database_url_to_filter_subprocess() {
        let template = load_template("postfix-main.cf.txt")
            .expect("postfix-main.cf.txt template should be loadable");
        assert!(
            template.contains("export_environment") && template.contains("DATABASE_URL"),
            "main.cf template must export DATABASE_URL so the pipe filter subprocess can connect to the database"
        );
    }

    // ── build_virtual_alias_entries tests ──

    use super::build_recipient_bcc_entries;
    use super::build_virtual_alias_entries;
    use crate::db::{Account, Alias, Forwarding};

    fn make_alias(source: &str, destination: &str, domain: &str) -> Alias {
        Alias {
            id: 1,
            domain_id: 1,
            source: source.to_string(),
            destination: destination.to_string(),
            active: true,
            tracking_enabled: false,
            sort_order: 0,
            domain_name: Some(domain.to_string()),
        }
    }

    fn make_forwarding(source: &str, destination: &str, keep_copy: bool) -> Forwarding {
        Forwarding {
            id: 1,
            domain_id: 1,
            source: source.to_string(),
            destination: destination.to_string(),
            active: true,
            keep_copy,
            domain_name: Some("example.com".to_string()),
        }
    }

    fn make_account(username: &str, domain: &str) -> Account {
        Account {
            id: 1,
            domain_id: 1,
            username: username.to_string(),
            password_hash: String::new(),
            name: String::new(),
            active: true,
            quota: 0,
            domain_name: Some(domain.to_string()),
        }
    }

    #[test]
    fn catch_all_entries_come_before_specific_entries() {
        let aliases = vec![
            make_alias("info@example.com", "info@other.com", "example.com"),
            make_alias("*@example.com", "catchall@tyyi.net", "example.com"),
        ];
        let entries = build_virtual_alias_entries(&aliases, &[], &[]);
        // Catch-all must appear before the specific entry
        let sources: Vec<&str> = entries.iter().map(|(s, _)| s.as_str()).collect();
        let catch_all_pos = sources.iter().position(|&s| s == "@example.com").unwrap();
        let specific_pos = sources.iter().position(|&s| s == "info@example.com").unwrap();
        assert!(
            catch_all_pos < specific_pos,
            "catch-all must be written before specific alias so the specific entry wins in LMDB"
        );
    }

    #[test]
    fn identity_entry_added_for_account_with_no_specific_alias_in_catch_all_domain() {
        // globalcommercecouncil.com has a catch-all but info@ has no explicit alias.
        // info@globalcommercecouncil.com should receive a self-referential identity entry
        // so that Postfix delivers to its mailbox instead of the catch-all.
        let aliases = vec![make_alias(
            "*@globalcommercecouncil.com",
            "m@tyyi.net",
            "globalcommercecouncil.com",
        )];
        let accounts = vec![make_account("info", "globalcommercecouncil.com")];
        let entries = build_virtual_alias_entries(&aliases, &[], &accounts);

        let identity = entries
            .iter()
            .find(|(src, dst)| src == "info@globalcommercecouncil.com" && dst == "info@globalcommercecouncil.com");
        assert!(
            identity.is_some(),
            "identity entry must be added for info@globalcommercecouncil.com to prevent catch-all interception"
        );
    }

    #[test]
    fn no_identity_entry_when_explicit_alias_already_exists() {
        // info@example.com already has an explicit alias; no identity entry should be added.
        let aliases = vec![
            make_alias("*@example.com", "catchall@tyyi.net", "example.com"),
            make_alias("info@example.com", "info@specific.com", "example.com"),
        ];
        let accounts = vec![make_account("info", "example.com")];
        let entries = build_virtual_alias_entries(&aliases, &[], &accounts);

        let info_entries: Vec<_> = entries
            .iter()
            .filter(|(src, _)| src == "info@example.com")
            .collect();
        assert_eq!(
            info_entries.len(),
            1,
            "there should be exactly one entry for info@example.com (the explicit alias)"
        );
        assert_eq!(
            info_entries[0].1, "info@specific.com",
            "the entry must be the explicit alias destination, not an identity"
        );
    }

    #[test]
    fn no_identity_entry_for_account_in_domain_without_catch_all() {
        // No catch-all for example.com; accounts there should not get identity entries.
        let aliases = vec![make_alias("*@other.com", "catchall@tyyi.net", "other.com")];
        let accounts = vec![make_account("info", "example.com")];
        let entries = build_virtual_alias_entries(&aliases, &[], &accounts);

        let has_identity = entries
            .iter()
            .any(|(src, dst)| src == "info@example.com" && dst == "info@example.com");
        assert!(
            !has_identity,
            "no identity entry should be added when the account domain has no catch-all"
        );
    }

    #[test]
    fn forwarding_catch_all_also_triggers_identity_entries() {
        // A catch-all defined as a Forwarding (not Alias) must also trigger identity entries.
        let forwardings = vec![make_forwarding("@example.com", "forward@tyyi.net", false)];
        let accounts = vec![make_account("bob", "example.com")];
        let entries = build_virtual_alias_entries(&[], &forwardings, &accounts);

        let identity = entries
            .iter()
            .find(|(src, dst)| src == "bob@example.com" && dst == "bob@example.com");
        assert!(
            identity.is_some(),
            "forwarding catch-all must also trigger identity entries for mailbox accounts"
        );
    }

    #[test]
    fn inactive_alias_is_excluded_from_entries() {
        let mut alias = make_alias("*@example.com", "catchall@tyyi.net", "example.com");
        alias.active = false;
        let entries = build_virtual_alias_entries(&[alias], &[], &[]);
        assert!(entries.is_empty(), "inactive aliases must not appear in the output");
    }

    #[test]
    fn keep_copy_forwarding_is_excluded_from_virtual_aliases() {
        // keep_copy=true forwardings must NOT appear in virtual_aliases to avoid the
        // Postfix loop-detection issue (self-referential alias destinations are dropped
        // in virtual-mailbox domains).  Local delivery happens via virtual_mailbox_maps;
        // the external copy is handled by recipient_bcc_maps.
        let fwd = make_forwarding("newsletter@example.com", "external@other.com", true);
        let entries = build_virtual_alias_entries(&[], &[fwd], &[]);
        assert!(
            entries.is_empty(),
            "keep_copy forwarding must not appear in virtual_alias_maps"
        );
    }

    #[test]
    fn keep_copy_non_catch_all_forwarding_appears_in_recipient_bcc_entries() {
        let fwd = make_forwarding("newsletter@example.com", "external@other.com", true);
        let bcc_entries = build_recipient_bcc_entries(&[fwd]);
        assert_eq!(bcc_entries.len(), 1);
        assert_eq!(
            bcc_entries[0],
            (
                "newsletter@example.com".to_string(),
                "external@other.com".to_string()
            ),
            "keep_copy forwarding must produce a recipient_bcc_maps entry for the external address"
        );
    }

    #[test]
    fn non_keep_copy_forwarding_does_not_appear_in_recipient_bcc_entries() {
        let fwd = make_forwarding("newsletter@example.com", "external@other.com", false);
        let bcc_entries = build_recipient_bcc_entries(&[fwd]);
        assert!(
            bcc_entries.is_empty(),
            "non-keep_copy forwarding must not appear in recipient_bcc_maps"
        );
    }

    #[test]
    fn multiple_keep_copy_destinations_are_comma_joined_in_bcc_entry() {
        let fwd1 = make_forwarding("newsletter@example.com", "addr1@other.com", true);
        let mut fwd2 = make_forwarding("newsletter@example.com", "addr2@other.com", true);
        fwd2.id = 2;
        let bcc_entries = build_recipient_bcc_entries(&[fwd1, fwd2]);
        assert_eq!(
            bcc_entries.len(),
            1,
            "multiple keep_copy destinations for the same source must be merged into one BCC entry"
        );
        let (source, bcc) = &bcc_entries[0];
        assert_eq!(source, "newsletter@example.com");
        assert!(
            bcc.contains("addr1@other.com") && bcc.contains("addr2@other.com"),
            "all keep_copy destinations must appear in the BCC value; got: {}",
            bcc
        );
    }

    #[test]
    fn keep_copy_forwarding_in_catch_all_domain_allows_identity_entry() {
        // When a keep_copy forwarding exists but the domain also has a catch-all,
        // the source address must NOT be in specific_sources (so that the accounts
        // loop can add an identity entry to prevent the catch-all from intercepting mail).
        let catchall = make_alias("*@example.com", "catchall@tyyi.net", "example.com");
        let fwd = make_forwarding("newsletter@example.com", "external@other.com", true);
        let account = make_account("newsletter", "example.com");
        let entries = build_virtual_alias_entries(&[catchall], &[fwd], &[account]);
        let identity = entries
            .iter()
            .find(|(src, dst)| src == "newsletter@example.com" && dst == "newsletter@example.com");
        assert!(
            identity.is_some(),
            "an identity entry must be added for the keep_copy source to prevent catch-all interception"
        );
    }

    #[test]
    fn inactive_account_does_not_receive_identity_entry() {
        let aliases = vec![make_alias("*@example.com", "catchall@tyyi.net", "example.com")];
        let mut account = make_account("alice", "example.com");
        account.active = false;
        let entries = build_virtual_alias_entries(&aliases, &[], &[account]);
        let has_identity = entries
            .iter()
            .any(|(src, dst)| src == "alice@example.com" && dst == "alice@example.com");
        assert!(
            !has_identity,
            "inactive accounts must not receive identity entries"
        );
    }
}

// ── Certificate and DH parameter generation ──

pub fn generate_tls_certificate(hostname: &str, force: bool) -> Result<(), String> {
    let cert_path = "/data/ssl/cert.pem";
    let key_path = "/data/ssl/key.pem";
    if !force
        && Path::new(cert_path).exists()
        && Path::new(key_path).exists()
        && fs::read(cert_path).map(|c| !c.is_empty()).unwrap_or(false)
        && fs::read(key_path).map(|c| !c.is_empty()).unwrap_or(false)
    {
        info!("[config] existing TLS certificate and key found, skipping certificate generation");
        return Ok(());
    }
    info!("[config] generating self-signed TLS certificate for hostname={}", hostname);
    
    // Sanitize hostname for use in certificate subject
    let safe_hostname: String = hostname.chars()
        .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-')
        .collect();
    
    if safe_hostname.is_empty() {
        return Err("hostname is empty or contains only invalid characters".to_string());
    }
    
    // Create SSL directory if it doesn't exist
    if let Err(e) = fs::create_dir_all("/data/ssl") {
        error!("[config] failed to create /data/ssl directory: {}", e);
        return Err(format!("failed to create SSL directory: {}", e));
    }
    
    // Create OpenSSL config file with SAN extension
    // Modern TLS clients require Subject Alternative Name (SAN) to be present
    let openssl_config = format!(
        "[req]\n\
         default_bits = 2048\n\
         prompt = no\n\
         default_md = sha256\n\
         distinguished_name = dn\n\
         x509_extensions = v3_req\n\
         \n\
         [dn]\n\
         CN = {}\n\
         \n\
         [v3_req]\n\
         subjectAltName = @alt_names\n\
         \n\
         [alt_names]\n\
         DNS.1 = {}\n\
         DNS.2 = localhost\n\
         IP.1 = 127.0.0.1\n",
        safe_hostname, safe_hostname
    );
    
    // Use a unique temporary file to avoid race conditions
    // Note: In Docker container context, /tmp is isolated and single-process
    let uuid = uuid::Uuid::new_v4();
    let config_path = format!("/tmp/openssl-cert-{}.cnf", uuid);
    
    if let Err(e) = fs::write(&config_path, &openssl_config) {
        error!("[config] failed to write OpenSSL config file: {}", e);
        return Err(format!("failed to write OpenSSL config: {}", e));
    }
    
    // Generate certificate with SAN extension
    let result = Command::new("openssl")
        .args([
            "req", "-new", "-newkey", "rsa:2048", "-days", "3650",
            "-nodes", "-x509",
            "-config", &config_path,
            "-keyout", "/data/ssl/key.pem",
            "-out", "/data/ssl/cert.pem",
        ])
        .output();
    
    // Clean up config file
    if let Err(e) = fs::remove_file(&config_path) {
        warn!("[config] failed to clean up temporary OpenSSL config file: {}", e);
    }
    
    match result {
        Ok(output) if output.status.success() => {
            // Set secure permissions on the private key
            match Command::new("chmod").args(["600", "/data/ssl/key.pem"]).output() {
                Ok(o) if o.status.success() => debug!("[config] set key.pem permissions to 600"),
                Ok(o) => warn!("[config] chmod 600 key.pem exited with status {}", o.status),
                Err(e) => warn!("[config] failed to set key.pem permissions: {}", e),
            }
            info!("[config] TLS certificate with SAN generated successfully");
            Ok(())
        }
        Ok(output) => {
            let stderr = String::from_utf8_lossy(&output.stderr);
            error!("[config] openssl failed: {}", stderr);
            Err(format!("openssl failed: {}", stderr))
        }
        Err(e) => {
            error!("[config] failed to run openssl: {}", e);
            Err(format!("failed to run openssl: {}", e))
        }
    }
}

pub fn generate_dh_parameters() -> Result<(), String> {
    let dh_path = "/usr/share/dovecot/dh.pem";
    
    // Check if DH parameters already exist
    if Path::new(dh_path).exists() {
        info!("[config] DH parameters already exist at {}, skipping generation", dh_path);
        return Ok(());
    }
    
    info!("[config] generating Diffie-Hellman parameters (this may take a while)");
    
    // Create dovecot directory if it doesn't exist
    if let Err(e) = fs::create_dir_all("/usr/share/dovecot") {
        error!("[config] failed to create /usr/share/dovecot directory: {}", e);
        return Err(format!("failed to create directory: {}", e));
    }
    
    // Generate DH parameters
    let result = Command::new("openssl")
        .args(["dhparam", "-out", dh_path, "2048"])
        .output();
    
    match result {
        Ok(output) if output.status.success() => {
            info!("[config] DH parameters generated successfully");
            Ok(())
        }
        Ok(output) => {
            let stderr = String::from_utf8_lossy(&output.stderr);
            error!("[config] openssl dhparam failed: {}", stderr);
            Err(format!("openssl dhparam failed: {}", stderr))
        }
        Err(e) => {
            error!("[config] failed to run openssl dhparam: {}", e);
            Err(format!("failed to run openssl dhparam: {}", e))
        }
    }
}

pub fn generate_all_certificates(hostname: &str, force: bool) -> Result<(), String> {
    info!("[config] generating all certificates and DH parameters for hostname={}", hostname);
    
    // Generate TLS certificate
    generate_tls_certificate(hostname, force)?;
    
    // Generate DH parameters
    generate_dh_parameters()?;
    
    info!("[config] all certificates and DH parameters generated successfully");
    Ok(())
}
